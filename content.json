{"meta":{"title":"ZZY补完计划","subtitle":null,"description":"God is in his heaven,all is right with the world.","author":"zzycreate","url":"https://github.com/zzycreate"},"pages":[{"title":"Abort","date":"2018-10-01T15:35:22.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"abort/index.html","permalink":"https://github.com/zzycreate/abort/index.html","excerpt":"","text":"ZZY补全计划@card{ God is in his heaven,all is right with the world. } @timeline{ 联系方式@item{ GitHubhttps://github.com/zzycreate } @item{ Giteehttps://gitee.com/zzycreate } @item{ E-mailzzycreate@gmail.com } } 虽然知道没什么用，但还是贴出来占个位置@column-2{ @card{ 微信 } @card{ 支付宝 } }"},{"title":"categories","date":"2018-09-26T18:04:45.000Z","updated":"2020-05-12T01:17:23.859Z","comments":false,"path":"categories/index.html","permalink":"https://github.com/zzycreate/categories/index.html","excerpt":"","text":""},{"title":"收藏","date":"2018-10-02T11:16:16.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"collections/index.html","permalink":"https://github.com/zzycreate/collections/index.html","excerpt":"","text":"本页用以记录一些本人可能会用到的网站，相当于是网站收藏夹 技术@column-3{ @card{ V2EXV2EX 是一个关于分享和探索的地方，是一个偏技术向的个人网站，在这里有各种大佬，可以提问或者分享。每个人都应该为自己的言行负责，尽量给其他人提供有帮助的回复 } @card{ 逗比根据地逗比根据地是一个各种教程的博客网站，想要访问需要 科学上网，具体内容自行研究 } @card{ ChiphellChiphell 是一个各种数码科技产品发现和分享的平台，各种电脑组装、数码产品、资讯新闻、技术评测、土豪炫富，在此我只能说 打扰了 } @card{ tonymacx86tonymacx86 黑苹果 } @card{ MSDN 我告诉你msdn.itellyou 是一个个人性质的原版软件信息收录站点，收录有微软系各种版本的原版程序，使用起来很纯净，该网站是在看极客湾的视频时看到的，推荐大家使用 } @card{ TLD LISTTLD LIST 是一个域名比较的网站，可以使用来比较各顶级域的价格和权益，查看直观 } @card{ Chrome 拓展商店有时候忘记怎么打开商店，记录一下网址方便使用 } @card{ EMOJI CHEAT SHEETEMOJI CHEAT SHEET 是 GitHub 支持的markdown语法的emoji，可以直接在markdown中写表情 } @card{ fontawesomefontawesome 是一个图标网站，本站用的主题 Indigo 菜单中的图标就是使用的 fontawesome } @card{ icon8Icon8 是一个 icons 图标分享网站 } @card{ leetcode算法 刷题 } @card{ 网站模板} @card{ cron表达式} @card{ linux命令在线手册} @card{ 前端组件} @card{ 中文文案排版指北中文排版的各种规范 } @card{ CyC2018/CS-Notes计算机科学学习笔记，学习基础知识，提高个人技术水平 } @card{ Guava 官方教程} } 动漫@column-3{ @card{ Bangumi 番组计划一个专注于动漫、音乐、游戏领域，帮助你分享、发现与结识同好的ACG网络。 } @card{ AnitamaAnitama 面向华语动漫爱好者的网络媒体 } @card{ 嘟嘟噜好用又好玩的追番网站 } @card{ ISML 世萌世界最萌大会，简称 世萌，感受厨力的世界吧 } } 资源@column-3{ @card{ 动漫花园资源网动漫花园 字幕组翻译分享学习的网站， 需要 科学上网 } @card{ PIXIVP站，日本同人绘画站，网站禁中国IP } @card{ Pixiv Illustration Collectionpixiv 高级搜索 } @card{ WallHavenWallHaven 壁纸网站，各种分辨率大小的图片，赏心悦目。 } @card{ Multi-service image searchMulti-service image search 动漫图片搜索服务，查找图片源站 } @card{ SauceNAO也是一个动漫图片搜索网站，查找p站会更准确一点 } } 其他@column-3{ @card{ 奶牛关游戏分享推荐网站 } @card{ NGANGA 精英玩家俱乐部 } @card{ Eshop比价任天堂 e-shop 游戏比价 } @card{ FANDOM娱乐文化分享网站，动漫、游戏、电影、电视等方方面面 } @card{ SCP基金会SCP基金会已经介入调查 } @card{ 有趣网站之家收藏全球最有趣的网站 } @card{ Rainy Mood听雨 } @card{ doutui.me抖腿 } @card{ ilidilidbilibili 镜像 } @card{ nicetool+} @card{ 在线工具} @card{ 爱范儿} @card{ 字幕组} @card{ G胖的微笑} } 酷炫网站@card{ 魔法少女サイト Flame makemepulse 2016年、2017年、2018年 Rome MikuTap } # 里世界&gt; 恭喜你发现里世界## 琉璃神社## Iwara## E-hentai## 酸酸乳的教程## 鸡场的养成方法## torrentkitty## nyaa"},{"title":"友情链接","date":"2018-10-01T15:10:32.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"links/index.html","permalink":"https://github.com/zzycreate/links/index.html","excerpt":"","text":"排名不分先后 @card{ 好友 码志 打码改变人生 Swagger Talk is cheap , show me the code . ThrowsException的博客 Work And Life,Code And Book } @card{ 大佬 一些网上看见的酷炫大佬博客. 腾讯ISUX 易象辞 CRIMX Never More Thinkful 魔法少女サイト }"},{"title":"tags","date":"2018-09-26T18:04:03.000Z","updated":"2020-05-12T01:17:23.859Z","comments":false,"path":"tags/index.html","permalink":"https://github.com/zzycreate/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java常用对象转换之 Stream 流","slug":"java-convert-example-stream","date":"2019-07-14T19:23:47.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"2019/07/14/java-convert-example-stream/","link":"","permalink":"https://github.com/zzycreate/2019/07/14/java-convert-example-stream/","excerpt":"平时的开发中会经常遇到一些对象需要转换，本项目记录一些常见对象转换的方法，例如：文件转换、日期时间转换、stream流转换、集合对象转换等, 具体的示例代码见 github 项目：zzycreate/java-convert-example本文记录一些常用的 Stream 操作，以备需要时直接使用","text":"平时的开发中会经常遇到一些对象需要转换，本项目记录一些常见对象转换的方法，例如：文件转换、日期时间转换、stream流转换、集合对象转换等, 具体的示例代码见 github 项目：zzycreate/java-convert-example本文记录一些常用的 Stream 操作，以备需要时直接使用 流的基本构成Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。 Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。 而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。 Stream 流的使用基本分为三种操作：生成 Stream 流数据源、Stream 流中值操作、Stream 流结束操作。另外还有 short-circuiting 操作作为补充。 Stream 流的生成想要获取 Stream 流数据源有很多种方式： 从集合中获取：集合对象（List、Set、Queue等）的 stream()、parallelStream() 方法可以直接获取 Stream 对象 从数组中获取：数据对象可以利用 Arrays.stream(T[] array) 或者 Stream.of() 的工具方法获取 Stream 对象 从IO流中获取：BufferedReader 提供了 lines() 方法可以逐行获取IO流里面的数据 静态工厂方法：Stream.of(Object[])、IntStream.range(int, int)、Stream.iterate(Object, UnaryOperator) 等静态工厂方法可以提供 Stream 对象 Files类的操作路径的方法：如list、find、walk等。 随机数流：Random.ints() 其他诸如 Random.ints()、BitSet.stream()、Pattern.splitAsStream(java.lang.CharSequence)、JarFile.stream() 等方法 更底层的使用StreamSupport，它提供了将Spliterator转换成流的方法。 Stream 流的中间操作(Intermediate)一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。只有在 Terminal 操作执行时才会真正的执行这些 Intermediate 操作。 常用的 Intermediate 操作有：map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered Stream 流的执行操作(Terminal)一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。 常用的 Terminal 操作有：forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator Short-circuiting当操作一个无限大的 Stream，而又希望在有限时间内完成操作，则在管道内拥有一个 short-circuiting 操作是必要非充分条件。 常用的 Short-circuiting 操作有：anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit 生成 Stream 流数据源集合对象 -&gt; Stream集合对象本身提供了 stream() 和 parallelStream() ，两个方法可以直接获取 Stream 流 Stream&lt;String&gt; listStream = list.stream();Stream&lt;String&gt; listParallelStream = list.parallelStream();Stream&lt;String&gt; setStream = set.stream();Stream&lt;String&gt; setParallelStream = set.parallelStream(); 数组对象 -&gt; Stream数组对象转换需要利用工具类 Arrays、 Stream 的静态方法 Stream&lt;String&gt; arrayStream = Arrays.stream(array);Stream&lt;String&gt; arrayStream1 = Stream.of(array); IO 流 -&gt; StreamIO 流可以包装成 BufferedReader 转换为 Stream BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;input.txt&quot;), StandardCharsets.UTF_8));Stream&lt;String&gt; stream = reader.lines(); 流对象提供的构造方法IntStream intStream = IntStream.range(1, 4);DoubleStream doubleStream = DoubleStream.builder().add(1.1).add(2.1).add(3.1).add(4.1).build();LongStream longStream = LongStream.of(1L, 2L, 3L, 4L); Stream 流的 Intermediate 操作示例代码： StreamIntermediateExample.java mapmap 的作用就是把 input Stream 的每一个元素，映射成 output Stream 的另外一个元素。 // 转大写List&lt;String&gt; stringList = list.stream() .map(String::toUpperCase) .collect(Collectors.toList()); // [ABC, EFG, HIJ]// 数据计算List&lt;Integer&gt; intList = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9).stream() .map(n -&gt; n * n) .collect(Collectors.toList()); // [1, 4, 9, 16, 25, 36, 49, 64, 81]// 获取对象属性List&lt;String&gt; list = list.stream() .map(Item::getDetail).map(ItemDetail::getValue) .collect(Collectors.toList()); // [v1, v5, v3, v2, v4] flatMapflatMap 把 input Stream 中的层级结构扁平化 Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of( Arrays.asList(1), Arrays.asList(2, 3), Arrays.asList(4, 5, 6));// 将集合对象里面的数据拿出来转换为扁平结构Stream&lt;Integer&gt; outputStream = inputStream. flatMap((childList) -&gt; childList.stream()); // [1, 2, 3, 4, 5, 6] filterfilter 对原始 Stream 进行某项测试，通过测试的元素被留下来生成一个新 Stream。 Integer[] sixNums = &#123;1, 2, 3, 4, 5, 6&#125;;// 对2取模等于0的是偶数，filter留下数字中的偶数Integer[] evens = Stream.of(sixNums) .filter(n -&gt; n % 2 == 0) .toArray(Integer[]::new); // [2, 4, 6] distinctdistinct 是对元素进行去重，去重是利用了对象的 hashCode() 和 equals() 方法 如果distinct（）正在处理有序流，那么对于重复元素，将保留以遭遇顺序首先出现的元素，并且以这种方式选择不同元素是稳定的。在无序流的情况下，不同元素的选择不一定是稳定的，是可以改变的。distinct（）执行有状态的中间操作。在有序流的并行流的情况下，保持distinct（）的稳定性是需要很高的代价的，因为它需要大量的缓冲开销。如果我们不需要保持遭遇顺序的一致性，那么我们应该可以使用通过BaseStream.unordered（）方法实现的无序流。 Integer[] nums = &#123;1, 1, 2, 3, 4, 5, 4, 5, 6&#125;;Integer[] evens = Stream.of(nums) .distinct() .toArray(Integer[]::new);// [1, 2, 3, 4, 5, 6] sortedsorted 方法用于排序，利用 Comparator 类的静态方法可以快速构造一个比较器实现排序。 List&lt;Integer&gt; list = Arrays.asList(5, 2, 4, 8, 6, 1, 9, 3, 7);// sorted() 无参方法为自然排序List&lt;Integer&gt; sorted = list.stream().sorted().collect(Collectors.toList());// [1, 2, 3, 4, 5, 6, 7, 8, 9]// 使用 Comparator.reverseOrder() 获得一个自然逆序比较器，用于逆序排序List&lt;Integer&gt; reverse = list.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toList());// [1, 2, 3, 4, 5, 6, 7, 8, 9]// 使用 Comparator.comparing() 获取一个自定义比较器，显现自定义对象的排序List&lt;Item&gt; codeSorted = StreamIntermediateExample.newItems().stream() .sorted(Comparator.comparing(Item::getCode)) .collect(Collectors.toList());// [Item(name=Name1, code=1, number=1.1, detail=ItemDetail(id=101, value=v1)), Item(name=Name2, code=2, number=2.2, detail=ItemDetail(id=202, value=v2)), Item(name=Name3, code=3, number=3.3, detail=ItemDetail(id=303, value=v3)), Item(name=Name4, code=4, number=4.4, detail=ItemDetail(id=404, value=v4)), Item(name=Name5, code=5, number=5.5, detail=ItemDetail(id=505, value=v5))]List&lt;Item&gt; codeReverse = StreamIntermediateExample.newItems().stream() .sorted(Comparator.comparing(Item::getCode).reversed()) .collect(Collectors.toList());// [Item(name=Name5, code=5, number=5.5, detail=ItemDetail(id=505, value=v5)), Item(name=Name4, code=4, number=4.4, detail=ItemDetail(id=404, value=v4)), Item(name=Name3, code=3, number=3.3, detail=ItemDetail(id=303, value=v3)), Item(name=Name2, code=2, number=2.2, detail=ItemDetail(id=202, value=v2)), Item(name=Name1, code=1, number=1.1, detail=ItemDetail(id=101, value=v1))] unordered某些流的返回的元素是有确定顺序的，我们称之为 encounter order。这个顺序是流提供它的元素的顺序，比如数组的encounter order是它的元素的排序顺序，List是它的迭代顺序(iteration order)，对于HashSet,它本身就没有encounter order。 一个流是否是encounter order主要依赖数据源和它的中间操作，比如数据源List和Array上创建的流是有序的(ordered)，但是在HashSet创建的流不是有序的。 sorted()方法可以将流转换成encounter order的，unordered可以将流转换成encounter order的。 注意，这个方法并不是对元素进行排序或者打散，而是返回一个是否encounter order的流。 可以参见 stackoverflow 上的问题： stream-ordered-unordered-problems 除此之外，一个操作可能会影响流的有序,比如map方法，它会用不同的值甚至类型替换流中的元素，所以输入元素的有序性已经变得没有意义了，但是对于filter方法来说，它只是丢弃掉一些值而已，输入元素的有序性还是保障的。 对于串行流，流有序与否不会影响其性能，只是会影响确定性(determinism)，无序流在多次执行的时候结果可能是不一样的。 对于并行流，去掉有序这个约束可能会提高性能，比如distinct、groupingBy这些聚合操作。 peekpeek() 接受一个 Consumer 消费者方法，而 map() 接受一个 Function 方法; Consumer 方法返回值是 void，而 Function 方法有返回值，peek 和 map 方法的区别主要在于流处理过程中返回值的不同。peek() 方法是 Intermediate 方法，而 forEach() 方法是 Terminal 方法; 如果 peek 方法后没有 Terminal 方法，则 peek 并不会真正的执行，forEach 方法则会立即执行。forEach 和 peek 都是接受 Consumer 对象的，因此如果在 Stream 流处理的过程中做一些数据操作或者打印操作，选择 peek 方法，该方法还会返回 Stream 流，用于下一步处理; 如果已经是处理的最后一步，则选择 forEach 用于最终执行整个流。 // [Abc, efG, HiJ] -&gt; [Abc, efG, HiJ]List&lt;String&gt; peek = StreamIntermediateExample.newStringList().stream() .peek(str -&gt; &#123; if (&quot;Abc&quot;.equals(str)) &#123; str = str.toUpperCase(); &#125; &#125;).collect(Collectors.toList()); peek 方法对对象的修改，会影响到集合里面的元素，但如果集合中是 String 这种，则不会改变，因为修改后的 String 在常量池中是另一个对象，由于 Consumer 无法返回该对象，Stream 内的元素仍然指向原来的 String。对对象的修改则是改变堆中对象的数据，对象的引用并没有发生变化，Stream 中的元素任然指向原对象，只是对象内部已经发生了改变。 // [Name1, Name5, Name3, Name2, Name4] -&gt; [xxx, Name5, Name3, Name2, Name4]List&lt;String&gt; peek1 = StreamIntermediateExample.newItems().stream() .peek(item -&gt; &#123; if (item.getCode() == 1) &#123; item.setName(&quot;xxx&quot;); &#125; &#125;) .map(Item::getName) .collect(Collectors.toList()); limitlimit 方法会对一个Stream进行截断操作，获取其前N个元素，如果原Stream中包含的元素个数小于N，那就获取其所有的元素； stream-limit List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6);// 截取指定元素位置以内的元素List&lt;Integer&gt; limit2 = numbers.stream().limit(2).collect(Collectors.toList());// [1, 2]List&lt;Integer&gt; limit6 = numbers.stream().limit(6).collect(Collectors.toList());// [1, 2, 3, 4, 5, 6]List&lt;Integer&gt; limit8 = numbers.stream().limit(8).collect(Collectors.toList());// [1, 2, 3, 4, 5, 6] skipskip 方法会返回一个丢弃原Stream的前N个元素后剩下元素组成的新Stream，如果原Stream中包含的元素个数小于N，那么返回空Stream； stream-limit List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6);// 忽略指定元素位置以内的元素List&lt;Integer&gt; skip2 = numbers.stream().skip(2).collect(Collectors.toList());// [3, 4, 5, 6]List&lt;Integer&gt; skip6 = numbers.stream().skip(6).collect(Collectors.toList());// []List&lt;Integer&gt; skip8 = numbers.stream().skip(8).collect(Collectors.toList());// [] parallelparallel stream是基于fork/join框架的,简单点说就是使用多线程来完成的,使用parallel stream时要考虑初始化fork/join框架的时间,如果要执行的任务很简单,那么初始化fork/join框架的时间会远多于执行任务所需时间,也就导致了效率的降低.根据附录doug Lee的说明,任务数量*执行方法的行数&gt;=10000或者执行的是消耗大量时间操作(如io/数据库)才有必要使用 Java 8为ForkJoinPool添加了一个通用线程池，这个线程池用来处理那些没有被显式提交到任何线程池的任务。它是ForkJoinPool类型上的一个静态元素，它拥有的默认线程数量等于运行计算机上的处理器数量。当调用Arrays类上添加的新方法时，自动并行化就会发生。比如用来排序一个数组的并行快速排序，用来对一个数组中的元素进行并行遍历。自动并行化也被运用在Java 8新添加的Stream API中。 并行流是 JDK8 对多线程的应用，但是难以控制，要想用好并行流，需要深入理解 ForkJoinPool 。以下的例子详阅：深入浅出parallelStream System.out.println(&quot;Hello World!&quot;);// 构造一个10000个元素的集合List&lt;Integer&gt; list = new ArrayList&lt;&gt;();for (int i = 0; i &lt; 10000; i++) &#123; list.add(i);&#125;// 统计并行执行list的线程Set&lt;Thread&gt; threadSet = new CopyOnWriteArraySet&lt;&gt;();// 并行执行list.stream().parallel().forEach(integer -&gt; &#123; Thread thread = Thread.currentThread(); // System.out.println(thread); // 统计并行执行list的线程 threadSet.add(thread);&#125;);System.out.println(&quot;threadSet一共有&quot; + threadSet.size() + &quot;个线程&quot;); // 6System.out.println(&quot;系统一个有&quot; + Runtime.getRuntime().availableProcessors() + &quot;个cpu&quot;); // 8List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();for (int i = 0; i &lt; 100000; i++) &#123; list1.add(i); list2.add(i);&#125;Set&lt;Thread&gt; threadSetTwo = new CopyOnWriteArraySet&lt;&gt;();CountDownLatch countDownLatch = new CountDownLatch(2);Thread threadA = new Thread(() -&gt; &#123; list1.stream().parallel().forEach(integer -&gt; &#123; Thread thread = Thread.currentThread(); // System.out.println(&quot;list1&quot; + thread); threadSetTwo.add(thread); &#125;); countDownLatch.countDown();&#125;);Thread threadB = new Thread(() -&gt; &#123; list2.stream().parallel().forEach(integer -&gt; &#123; Thread thread = Thread.currentThread(); // System.out.println(&quot;list2&quot; + thread); threadSetTwo.add(thread); &#125;); countDownLatch.countDown();&#125;);threadA.start();threadB.start();countDownLatch.await();System.out.println(&quot;threadSetTwo一共有&quot; + threadSetTwo.size() + &quot;个线程&quot;); // 9System.out.println(&quot;---------------------------&quot;);// [Thread[main,5,main],// Thread[ForkJoinPool.commonPool-worker-3,5,main],// Thread[ForkJoinPool.commonPool-worker-1,5,main],// Thread[ForkJoinPool.commonPool-worker-4,5,main],// Thread[ForkJoinPool.commonPool-worker-5,5,main],// Thread[ForkJoinPool.commonPool-worker-2,5,main]]System.out.println(threadSet);// [Thread[ForkJoinPool.commonPool-worker-6,5,main],// Thread[ForkJoinPool.commonPool-worker-7,5,main],// Thread[Thread-0,5,],// Thread[ForkJoinPool.commonPool-worker-5,5,main],// Thread[Thread-1,5,],// Thread[ForkJoinPool.commonPool-worker-4,5,main],// Thread[ForkJoinPool.commonPool-worker-3,5,main],// Thread[ForkJoinPool.commonPool-worker-2,5,main],// Thread[ForkJoinPool.commonPool-worker-1,5,main]]System.out.println(threadSetTwo);System.out.println(&quot;---------------------------&quot;);threadSetTwo.addAll(threadSet);// [Thread[ForkJoinPool.commonPool-worker-6,5,main],// Thread[ForkJoinPool.commonPool-worker-7,5,main],// Thread[Thread-0,5,],// Thread[ForkJoinPool.commonPool-worker-5,5,main],// Thread[Thread-1,5,],// Thread[ForkJoinPool.commonPool-worker-4,5,main],// Thread[ForkJoinPool.commonPool-worker-3,5,main],// Thread[ForkJoinPool.commonPool-worker-2,5,main],// Thread[ForkJoinPool.commonPool-worker-1,5,main],// Thread[main,5,main]]// 执行forEach本身的线程也作为线程池中的一个工作线程System.out.println(threadSetTwo);System.out.println(&quot;threadSetTwo一共有&quot; + threadSetTwo.size() + &quot;个线程&quot;);System.out.println(&quot;系统一个有&quot; + Runtime.getRuntime().availableProcessors() + &quot;个cpu&quot;); sequential通过parallel()方法可以将串行流转换成并行流,sequential()方法将流转换成串行流。 顺序流和并行流相对，这种使用的方法很少，暂时没有研究。 Stream 流的 Terminal 操作示例代码： StreamTerminalExample.java collectcollect 方法是 Terminal 操作，可以将 Stream 流转换为集合，Collectors 中提供了一些便捷的生成 Collector 的方法，例如 toList() 用于生成 List 列表，toSet() 可以用于生成 Set 堆，toMap() 可以用于生成 Map。 List&lt;String&gt; list = Arrays.asList(&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;, &quot;pear&quot;);List&lt;String&gt; collectList = list.stream().filter(s -&gt; s.length() &gt; 5).collect(Collectors.toList());//[orange, banana]Set&lt;String&gt; collectSet = list.stream().filter(s -&gt; s.length() &gt; 5).collect(Collectors.toSet());// [orange, banana] Collectors.toMap() 有三个重构方法，推荐至少使用三个参数的 toMap() 方法，BinaryOperator&lt;U&gt; mergeFunction这个参数有利于解决，生成Map时的主键重复问题，避免因为源数据问题产生问题。 Map&lt;Integer, Item&gt; collectMap1 = items.stream() .collect(Collectors.toMap(Item::getCode, Function.identity()));Map&lt;Integer, Item&gt; collectMap2 = StreamConstant.newItems().stream() .collect(Collectors.toMap(Item::getCode, Function.identity(), (a, b) -&gt; a)); toCollection() 可以用于生成各种各样自定义的集合结构。 Stack&lt;String&gt; collect = items.stream() .map(Item::getName) .collect(Collectors.toCollection(Stack::new)); Collector包含四种不同的操作：supplier（初始构造器）, accumulator（累加器）, combiner（组合器）， finisher（终结者）。 简单分组： Map&lt;Integer, List&lt;Item&gt;&gt; groupingByCollect = StreamConstant.newItems().stream() .collect(Collectors.groupingBy(Item::getCode)); 平均值： Double average = StreamConstant.newItems().stream() .collect(Collectors.averagingInt(Item::getCode)); 统计： IntSummaryStatistics summaryStatistics = StreamConstant.newItems().stream() .collect(Collectors.summarizingInt(Item::getCode));// IntSummaryStatistics&#123;count=5, sum=15, min=1, average=3.000000, max=5&#125; 拼接(三个参数分别是：连接符、字符串前缀、字符串后缀)： String join = list.stream() .collect(Collectors.joining(&quot; and &quot;, &quot;The &quot;, &quot; are fruits&quot;));// The apple and orange and banana and pear are fruits Collector.of() 方法可以创建了一个新的collector，我们必须给这个collector提供四种功能：supplier, accumulator, combiner,finisher. supplier 初始化构造分割符；accumulator 处理数据，并叠加数据；combiner 进行数据连接，finisher 生成最终数据。 Collector&lt;Item, StringJoiner, String&gt; personNameCollector = Collector.of( () -&gt; new StringJoiner(&quot; | &quot;), // supplier (j, p) -&gt; j.add(p.getName().toUpperCase()), // accumulator (j1, j2) -&gt; j1.merge(j2), // combiner StringJoiner::toString); // finisherString names = StreamConstant.newItems().stream() .collect(personNameCollector);System.out.println(names); // NAME1 | NAME5 | NAME3 | NAME2 | NAME4 toArraytoArray() 方法可以将流中的数据放入一个数组中。无参方法只能生成 Object[] 对象数组，单参方法可以指定生成的数组类型。 List&lt;String&gt; list = Arrays.asList(&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;, &quot;pear&quot;);Object[] objects = list.stream().filter(s -&gt; s.length() &gt; 5).toArray();String[] strings = list.stream().filter(s -&gt; s.length() &gt; 5).toArray(String[]::new); forEach/forEachOrderedforEach 方法接收一个 Lambda 表达式，然后在 Stream 的每一个元素上执行该表达式。 一般认为，forEach 和常规 for 循环的差异不涉及到性能，它们仅仅是函数式风格与传统 Java 风格的差别。 // Java 8list.stream() .filter(s -&gt; s.length() &gt; 5) .forEach(System.out::println);// Pre-Java 8for (String s : list) &#123; if (s.length() &gt; 5) &#123; System.out.println(s); &#125;&#125; forEach 是 terminal 操作，因此它执行后，Stream 的元素就被“消费”掉了，你无法对一个 Stream 进行两次 terminal 运算。 Stream&lt;String&gt; stream = list.stream().filter(s -&gt; s.length() &gt; 5);stream.forEach(element -&gt; System.out.println(&quot;1: &quot;+element));// okstream.forEach(element -&gt; System.out.println(&quot;2: &quot;+element));// java.lang.IllegalStateException: stream has already been operated upon or closed 要想实现上述类似功能，可以使用 peek 方法，peek是中间方法，流还没有被消费掉。或者利用Supplier提供者，Supplier的get方法可以构造新的Stream。 Supplier&lt;Stream&lt;String&gt;&gt; streamSupplier= () -&gt; (list.stream().filter(s -&gt; s.length() &gt; 5));streamSupplier.get().forEach(element -&gt; System.out.println(&quot;1: &quot;+element));streamSupplier.get().forEach(element -&gt; System.out.println(&quot;2: &quot;+element)); forEachOrdered 是为了保证执行后数据的有序性。 reduceStream 的 reduce 方法，返回单个的结果值，并且reduce操作每处理一个元素总是创建一个新值。常用的方法有average、sum、min、max、count，都可以使用reduce方法实现。 &lt;U&gt; U reduce(U identity,BiFunction&lt;U,? super T,U&gt; accumulator,BinaryOperator&lt;U&gt; combiner)#第一个参数identity返回实例u，传递你要返回的U类型对象的初始化实例u, 用于提供一个循环计算的初始值#第二个参数累加器accumulator，可以使用二元ℷ表达式（即二元lambda表达式），声明你在u上累加你的数据来源t的逻辑#例如(u,t)-&gt;u.sum(t),此时lambda表达式的行参列表是返回实例u和遍历的集合元素t，函数体是在u上累加t#BinaryOperator 的函数方法为 apply(U u, T t), 第一个参数为上次函数计算的返回值，第二个参数为 Stream 中的元素，函数方法会将两个值计算apply，得到的值赋值给下次执行该方法的第一个参数#第三个参数组合器combiner，同样是二元ℷ表达式，(u,t)-&gt;u#lambda表达式行参列表同样是(u,t)，函数体返回的类型则要和第一个参数的类型保持一致 具体的一个示例： Supplier&lt;Stream&lt;Integer&gt;&gt; supplier = () -&gt; (Stream.of(1, 2, 3, 4).filter(p -&gt; p &gt; 2));List&lt;Integer&gt; result = supplier.get() .collect(() -&gt; new ArrayList&lt;&gt;(), (list, item) -&gt; list.add(item), (one, two) -&gt; one.addAll(two));System.out.println(result);// [3, 4]/* 或者使用方法引用 */result = supplier.get().collect(ArrayList::new, List::add, List::addAll);System.out.println(result);// [3, 4] min/max/count一般比较大小需要比较器 Comparator, min 和 max 返回值类型是 Optional。 count 是对满足条件的数据进行统计，计算次数。等价于 return mapToLong(e -&gt; 1L).sum(); Supplier&lt;Stream&lt;Integer&gt;&gt; supplier = () -&gt; (Stream.of(1, 2, 3, 4).filter(p -&gt; p &gt; 2));Optional&lt;Integer&gt; min = supplier.get().min(Integer::compareTo);// Optional[3]Optional&lt;Integer&gt; max = supplier.get().max(Integer::compareTo);// Optional[4]long count = supplier.get().count();// 2 anyMatch/allMatch/noneMatch allMatch：Stream 中全部元素符合传入的 predicate，返回 true anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true 它们都不是要遍历全部元素才能返回结果。例如 allMatch 只要一个元素不满足条件，就 skip 剩下的所有元素，返回 false。对清单 13 中的 Person 类稍做修改，加入一个 age 属性和 getAge 方法。 boolean b1 = StreamConstant.newItems().stream().map(Item::getCode).anyMatch(i -&gt; i &gt; 3);// trueboolean b2 = StreamConstant.newItems().stream().map(Item::getCode).anyMatch(i -&gt; i &gt; 5);// falseboolean b3 = StreamConstant.newItems().stream().map(Item::getCode).allMatch(i -&gt; i &gt; 3);// falseboolean b4 = StreamConstant.newItems().stream().map(Item::getCode).allMatch(i -&gt; i &gt; 5);// falseboolean b5 = StreamConstant.newItems().stream().map(Item::getCode).noneMatch(i -&gt; i &gt; 3);// falseboolean b6 = StreamConstant.newItems().stream().map(Item::getCode).noneMatch(i -&gt; i &gt; 5);// true findFirst/findAnyfindFirst 是一个 termimal 兼 short-circuiting 操作，它总是返回 Stream 的第一个元素，或者空。findAny 是搜索到任何一个符合条件的结果返回，因为流可能是并行的，因此顺序可能不是确定的。如果顺序是确定的，使用 findFirst 可以方便的获取第一个元素。 Optional&lt;String&gt; first = StreamConstant.newStringList().stream().findFirst();// Optional[Abc]String any = StreamConstant.newStringList().stream() .filter(s -&gt; s.length() &gt; 5).findAny().orElse(&quot;ERROR&quot;);// ERROR 有效的特殊用法自定义去重利用 Map 的 key 不能重复的特性进行去重，实现下方静态方法，在需要的使用结合 filter 和 distinctByKey 方法进行去重。 示例代码： DistinctByKey.java public static &lt;T&gt; Predicate&lt;T&gt; distinctByKey(Function&lt;? super T, ?&gt; keyExtractor) &#123; Map&lt;Object, Boolean&gt; seen = new ConcurrentHashMap&lt;&gt;(); // putIfAbsent 如果map中有值，则返回原值，新值也不会放入map中，如果原来没有值，则返回null，本次put的值也会放入map中 return t -&gt; seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == null;&#125; 使用的时候只需要使用 filter 过滤掉重复项： 示例代码： StreamSpecialExample.java items.stream().filter(distinctByKey(Item::getName)).collect(Collectors.toList()); 求和BigDecimal 对象求和: //计算 总金额BigDecimal totalMoney = stream().map(Item::getDetail).map(ItemDetail::getMoney) .reduce(BigDecimal.ZERO, BigDecimal::add);System.err.println(&quot;totalMoney:&quot; + totalMoney.setScale(2, RoundingMode.HALF_UP)); //totalMoney:166.50 基本类型求和： //计算 数量double sum = stream().mapToDouble(Item::getNumber).sum();System.err.println(&quot;sum:&quot; + sum); //sum:16.5 参考文章：Java 8 中的 Streams API 详解Java Stream 详解 ——鸟窝Java 8 Stream 教程","categories":[{"name":"编码","slug":"编码","permalink":"https://github.com/zzycreate/categories/编码/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://github.com/zzycreate/tags/Java/"},{"name":"java-convert-example","slug":"java-convert-example","permalink":"https://github.com/zzycreate/tags/java-convert-example/"},{"name":"Stream","slug":"Stream","permalink":"https://github.com/zzycreate/tags/Stream/"},{"name":"JDK8","slug":"JDK8","permalink":"https://github.com/zzycreate/tags/JDK8/"}]},{"title":"Java常用对象转换之时间操作","slug":"java-convert-example-datetime","date":"2019-06-29T17:07:47.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"2019/06/29/java-convert-example-datetime/","link":"","permalink":"https://github.com/zzycreate/2019/06/29/java-convert-example-datetime/","excerpt":"平时的开发中会经常遇到一些对象需要转换，本项目记录一些常见对象转换的方法，例如：文件转换、日期时间转换、stream流转换、集合对象转换等, 具体的示例代码见 github 项目：zzycreate/java-convert-example本文记录一些常用的时间操作，以备需要时直接使用","text":"平时的开发中会经常遇到一些对象需要转换，本项目记录一些常见对象转换的方法，例如：文件转换、日期时间转换、stream流转换、集合对象转换等, 具体的示例代码见 github 项目：zzycreate/java-convert-example本文记录一些常用的时间操作，以备需要时直接使用 java 的时间操作 APIjava.util 包的时间操作jdk 1.1 就开始提供了基础的日期时间相关的功能，java.util.Date、java.util.Calendar、java.text.DateFormat、java.sql.Date、java.sql.Time、java.sql.Timestamp 等是 jdk 1.1 中常用的日期时间类，java.util.Date 代表了时间，java.util.Calendar 代表了日期，java.text.DateFormat用于格式化时间，java.sql.Date 是 java.util.Date 的包装类，代表了数据库中的 DATE，java.sql.Time 代表数据库的时间（不含日期）, java.sql.Timestamp 代表了数据库的 TIMESTAMP。 SimpleDateFormat 时间格式化常用字符及含义： 字母 含义 示例 G 纪元 在 Locale.CHINA语言环境下，如 ‘公元’;在Locale.US语言环境下，如 ‘AD’ y 年份。一般用 yy 表示两位年份，yyyy 表示 4 位年份 使用 yy 表示的年扮，如 11；使用 yyyy 表示的年份，如 2011 M 月份。一般用 MM 表示月份，如果使用 MMM，则会根据语言环境显示不同语言的月份 使用 MM 表示的月份，如 05；使用 MMM 表示月份，在 Locale.CHINA语言环境下，如“十月”；在Locale.US语言环境下，如 Oct d 月份中的天数。一般用 dd 表示天数 使用 dd 表示的天数，如 10 D 年份中的天数。表示当天是当年的第几天， 用 D 表示 使用 D 表示的年份中的天数，如 295 E 星期几。用 E 表示，会根据语言环境的不同， 显示不同语言的星期几 使用 E 表示星期几，在 Locale.CHINA 语言环境下，如“星期四”；在 Locale.US 语言环境下，如 Thu H 一天中的小时数（0~23)。一般用 HH 表示小时数 使用 HH 表示的小时数，如 18 h 一天中的小时数（1~12)。一般使用hh表 示小时数 使用 hh 表示的小时数，如 10 (注意 10 有可能是 10 点，也可能是 22 点） m 分钟数。一般使用 mm 表示分钟数 使用 mm 表示的分钟数，如 29 s 秒数。一般使用 ss 表示秒数 使用 ss 表示的秒数，如 38 S 毫秒数。一般使用 SSS 表示毫秒数 使用 SSS 表示的毫秒数，如 156 Date 代表了一个特定的时间，可以精确到毫秒，也能表示年月日等日期概念。 但 util 中的日期时间操作存在一些问题： Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。 java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身就是一个非常糟糕的设计。 对于时间、时间戳、格式化以及解析，并没有一些明确定义的类。对于格式化和解析的需求，我们有java.text.DateFormat抽象类，但通常情况下，SimpleDateFormat类被用于此类需求。 所有的日期类都是可变的，因此他们都不是线程安全的，这是Java日期类最大的问题之一。 日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有的问题。 java.time 包的时间操作Java 8 新增的日期时间 API 遵循 JSR 310 设计规范，解决上述 API 中的缺陷。 主要的操作对象有： java.time.LocalTime: 时间 java.time.LocalDate: 日期 java.time.LocalDateTime: 日期/时间 java.time.ZoneId: 时区 java.time.ZoneOffset: 时区偏移量 java.time.ZonedDateTime: 带时区信息的日期/时间 java.time.Instant: 时刻（时间戳） java.time.Duration java.time.Period: 时间段 这些对象都是线程安全，且不可变，API 方法设计简单，转换容易，配合 java.time.format.DateTimeFormatter 可以很容易的进行格式化。 以上这些对象的关联关系： LocalDateTime = LocalDate + LocalTime ZonedDateTime = LocalDateTime + ZoneId/ZoneOffset Instant = seconds + nano Java 8日期/时间API是JSR-310的实现，它的实现目标是克服旧的日期时间实现中所有的缺陷，新的日期/时间API的一些设计原则是： 不变性：新的日期/时间API中，所有的类都是不可变的，这对多线程环境有好处。 关注点分离：新的API将人可读的日期时间和机器时间（unix timestamp）明确分离，它为日期（Date）、时间（Time）、日期时间（DateTime）、时间戳（unix timestamp）以及时区定义了不同的类。 清晰：在所有的类中，方法都被明确定义用以完成相同的行为。举个例子，要拿到当前实例我们可以使用now()方法，在所有的类中都定义了format()和parse()方法，而不是像以前那样专门有一个独立的类。为了更好的处理问题，所有的类都使用了工厂模式和策略模式，一旦你使用了其中某个类的方法，与其他类协同工作并不困难。 实用操作：所有新的日期/时间API类都实现了一系列方法用以完成通用的任务，如：加、减、格式化、解析、从日期/时间中提取单独部分，等等。 可扩展性：新的日期/时间API是工作在ISO-8601日历系统上的，但我们也可以将其应用在非IOS的日历上。 java 1.1 日期/时间操作对象构造// 毫秒值long timestamp = System.currentTimeMillis();// java.util.Date 除了一下两种构造方法，其他构造方法均已过期Date date = new Date();Date date1 = new Date(timestamp);// sql date/time/timestamp 是针对SQL语言使用的，Date只有日期而没有时间，Time只有时间而没有日期java.sql.Date sqlDate = new java.sql.Date(timestamp);java.sql.Date sqlDate1 = new java.sql.Date(date1.getTime());java.sql.Time sqlTime = new java.sql.Time(timestamp);java.sql.Time sqlTime1 = new java.sql.Time(date1.getTime());java.sql.Timestamp sqlTimestamp = new java.sql.Timestamp(timestamp);java.sql.Timestamp sqlTimestamp1 = new java.sql.Timestamp(date1.getTime());// Calendar 代表日历, GregorianCalendar 代表公历Calendar calendar = Calendar.getInstance();GregorianCalendar gregorianCalendar = new GregorianCalendar(); 对象取值long timestamp = System.currentTimeMillis();Date date = new Date(timestamp);java.sql.Date sqlDate = new java.sql.Date(timestamp);java.sql.Time sqlTime = new java.sql.Time(timestamp);java.sql.Timestamp sqlTimestamp = new java.sql.Timestamp(timestamp);Calendar calendar = Calendar.getInstance();GregorianCalendar gregorianCalendar = new GregorianCalendar();// Date 除了 getTime() 方法可以获取时间戳毫秒值外，其他 get 方法在 jdk8 中均已过期，不推荐时间// sql date/time/timestamp 均为 util date 的子类，过期方法类似long s = date.getTime();long sqlTimes = sqlDate.getTime();long sqlTime1 = sqlTime.getTime();long sqlTime2 = sqlTimestamp.getTime();long sqlNano1 = sqlTimestamp.getNanos();long sqlNano2 = sqlTimestamp.getNanos();Date calendarTime = calendar.getTime();int year = calendar.get(Calendar.YEAR);// 由于月份是从0开始，一般 +1 之后才和人的主观感受一致int month = calendar.get(Calendar.MONTH) + 1;int dateNum = calendar.get(Calendar.DATE);int hour = calendar.get(Calendar.HOUR_OF_DAY);int minute = calendar.get(Calendar.MINUTE);int second = calendar.get(Calendar.SECOND);// 星期int dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK);// 日期int dayOfMonth = calendar.get(Calendar.DAY_OF_MONTH);boolean isLeapYear = gregorianCalendar.isLeapYear(year); java 8 日期/时间操作JSR 303 的日期时间对象虽然多，但是操作的 API 基本类似，很容易理解，以下距离没有列举所有情况，但其他操作基本类似。 对象构造对象的创建基本都是 now (当前时间)、of (静态构造方法)、parse (文本解析)、at (维度组合)、to (对象转换)、between (区间) 等简单明了的 API。 示例代码： Jdk8TimeExample.java LocalTime time = LocalTime.now();LocalTime time1 = LocalTime.of(13, 14, 15);LocalTime time2 = LocalTime.ofSecondOfDay(47655);LocalTime time3 = LocalTime.parse(&quot;13:14:15&quot;);LocalDate date = LocalDate.now();LocalDate date1 = LocalDate.of(2019, 5, 10);LocalDate date2 = LocalDate.ofYearDay(2019, 130);LocalDate date3 = LocalDate.parse(&quot;2019-05-10&quot;);LocalDateTime dateTime = LocalDateTime.now();LocalDateTime dateTime1 = LocalDateTime.of(2019, 5, 10, 13, 14, 15);LocalDateTime dateTime2 = LocalDateTime.of(date, time);LocalDateTime dateTime3 = date.atStartOfDay();LocalDateTime dateTime4 = date.atTime(time);LocalDateTime dateTime5 = date.atTime(13, 14, 15);LocalDateTime dateTime6 = time.atDate(date);ZonedDateTime zonedDateTime = ZonedDateTime.now();ZonedDateTime zonedDateTime1 = dateTime.atZone(ZoneId.systemDefault());ZonedDateTime zonedDateTime2 = dateTime.atZone(ZoneId.of(&quot;Asia/Shanghai&quot;));LocalDateTime dateTime7 = zonedDateTime.toLocalDateTime();LocalDate date4 = zonedDateTime.toLocalDate();LocalTime time4 = zonedDateTime.toLocalTime();Instant instant = dateTime.toInstant(ZoneOffset.of(&quot;+08:00&quot;));Instant instant1 = zonedDateTime.toInstant();Instant instant2 = new Date().toInstant();Duration duration = Duration.between(time, time1);Period period = Period.between(date, date1); 对象取值和比较对象的 get 方法可以获取对象结构的组成部分，is方法可以用做时间的简单判断。 示例代码： Jdk8TimeExample.java ZonedDateTime zonedDateTime = ZonedDateTime.now();LocalDateTime dateTime = zonedDateTime.toLocalDateTime();LocalDate date = dateTime.toLocalDate();LocalTime time = dateTime.toLocalTime();int year = date.getYear();Month month = date.getMonth();int monthValue = date.getMonthValue();int dayOfYear = date.getDayOfYear();int dayOfMonth = date.getDayOfMonth();DayOfWeek dayOfWeek = date.getDayOfWeek();int hour = time.getHour();int minute = time.getMinute();int second = time.getSecond();int nano = time.getNano();ZoneId zone = zonedDateTime.getZone();ZoneOffset offset = zonedDateTime.getOffset();LocalDateTime now = LocalDateTime.now();boolean isBefore = dateTime.isBefore(now);boolean isAfter = dateTime.isAfter(now);boolean isLeapYear = dateTime.toLocalDate().isLeapYear(); 时间加减LocalDate date = LocalDate.now();LocalDate minus1 = date.minus(1, ChronoUnit.DAYS);LocalDate date1 = date.minusDays(1);LocalDate date2 = date.minusMonths(2);LocalDate plus1 = date.plus(1, ChronoUnit.WEEKS);LocalDate date3 = date.plusYears(1);LocalTime time = LocalTime.now();LocalTime minus2 = time.minus(1, ChronoUnit.SECONDS);LocalTime time1 = time.minusSeconds(2);LocalTime time2 = time.minusMinutes(30);LocalTime plus2 = time.plus(3, ChronoUnit.HALF_DAYS);LocalTime time3 = time.plusHours(2);LocalDateTime dateTime = LocalDateTime.now();LocalDateTime minus = dateTime.minus(10, ChronoUnit.SECONDS);LocalDateTime dateTime1 = dateTime.minusSeconds(10L);LocalDateTime dateTime2 = dateTime.minusDays(10L);LocalDateTime plus = dateTime.plus(10, ChronoUnit.SECONDS);LocalDateTime dateTime3 = dateTime.plusMinutes(10L);LocalDateTime dateTime4 = dateTime.plusMonths(5); 类型转换 以下为 jdk 1.1 时间日期与 jdk1.8 时间日期的转换 Date -&gt; Instant示例代码： DateLocalDateTimeConvertExample.java Instant instant = new Date().toInstant();Instant instant1 = Instant.ofEpochMilli(new Date().getTime()) Date -&gt; LocalDateTime/LocalDate/LocalTime示例代码： DateLocalDateTimeConvertExample.java LocalDateTime localDateTime = LocalDateTime.ofInstant(new Date().toInstant(), ZoneId.systemDefault());LocalDate localDate = LocalDateTime.ofInstant(new Date().toInstant(), ZoneId.systemDefault()).toLocalDate();LocalTime localTime = LocalDateTime.ofInstant(new Date().toInstant(), ZoneId.systemDefault()).toLocalTime(); Instant -&gt; Date示例代码： DateLocalDateTimeConvertExample.java Date date = new Date(Instant.now().toEpochMilli()); LocalDateTime -&gt; DateDate date = new Date(LocalDateTime.now().toInstant(ZoneOffset.of(&quot;+08:00&quot;)).toEpochMilli()); 以下为字符串与时间日期的转换 String -&gt; Date示例代码： DateTimeStringExample.java 使用 SimpleDateFormat 按照格式解析字符串，可能会出现异常，格式见前文表格。 try &#123; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); Date date = sdf.parse(&quot;2019-01-02 15:23:46&quot;);&#125; catch (ParseException e) &#123; e.printStackTrace();&#125; 或者间接利用 LocalDateTime 进行字符串解析 DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);LocalDateTime localDateTime = LocalDateTime.parse(&quot;2019-05-10 13:14:15&quot;, dateTimeFormatter);Date date = Date.from(localDateTime.toInstant(ZoneOffset.of(&quot;+08:00&quot;))); String -&gt; LocalDateTime示例代码： DateTimeStringExample.java DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);LocalDateTime dateTime = DateTimeStringExample.toLocalDateTime(&quot;2019-05-10 13:14:15&quot;, dateTimeFormatter); Date -&gt; String示例代码： DateExample.java 利用 SimpleDateFormat 进行时间的格式化： SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);String str = sdf.format(new Date); 利用 DateTimeFormatter 进行时间的格式化： ZonedDateTime zonedDateTime = date.toInstant().atZone(ZoneId.systemDefault());DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);String str = zonedDateTime.format(dateTimeFormatter); Instant -&gt; String示例代码： DateExample.java ZonedDateTime zonedDateTime = Instant.now().atZone(ZoneId.systemDefault());DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);String str = zonedDateTime.format(dateTimeFormatter); Date/Instant -&gt; epochMilli示例代码： DateExample.java long epochMilli = new Date().getTime();long epochMilli1 = Instant.now().toEpochMilli();long epochMilli2 = new Date().toInstant().toEpochMilli(); epochMilli -&gt; Date/Instant示例代码： DateExample.java long epochMilli = System.currentTimeMillis();Date date = new Date(epochMilli);Instant instant = Instant.ofEpochMilli(epochMilli);","categories":[{"name":"编码","slug":"编码","permalink":"https://github.com/zzycreate/categories/编码/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://github.com/zzycreate/tags/Java/"},{"name":"java-convert-example","slug":"java-convert-example","permalink":"https://github.com/zzycreate/tags/java-convert-example/"},{"name":"datetime","slug":"datetime","permalink":"https://github.com/zzycreate/tags/datetime/"},{"name":"JSR 310","slug":"JSR-310","permalink":"https://github.com/zzycreate/tags/JSR-310/"}]},{"title":"Java常用对象转换之文件操作","slug":"java-convert-example-file","date":"2019-05-04T21:07:47.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"2019/05/04/java-convert-example-file/","link":"","permalink":"https://github.com/zzycreate/2019/05/04/java-convert-example-file/","excerpt":"平时的开发中会经常遇到一些对象需要转换，本项目记录一些常见对象转换的方法，例如：文件转换、日期时间转换、stream流转换、集合对象转换等, 具体的示例代码见 github 项目：zzycreate/java-convert-example本文记录一些常用的文件操作，以备需要时直接使用","text":"平时的开发中会经常遇到一些对象需要转换，本项目记录一些常见对象转换的方法，例如：文件转换、日期时间转换、stream流转换、集合对象转换等, 具体的示例代码见 github 项目：zzycreate/java-convert-example本文记录一些常用的文件操作，以备需要时直接使用 文件Java 为文件操作设计了很多的类，有数据相关的 IO Stream 流，与文件相关的File、Path等对文件系统的抽象。Java 的 io 包和几乎包含了所有操作输入、输出需要的类，另外 java1.4 开始推出的 nio 接口能更高效的完成一些工作。Java io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。所有这些流类代表了输入源和输出目标。一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。 IOIO 流分类： 按照流的流向分，可以分为输入流和输出流； 按照操作单元划分，可以划分为字节流和字符流； 按照流的角色划分为节点流和处理流。 按照操作方式分类： java IO Stream 操作方式分类 按照操作对象分类： java IO Stream 操作对象分类 IO 流基础对象： InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。 OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。 NIOjava 1.4 版本后，重新设计出了一套新的 IO 接口：Non-blocking IO(NIO) NIO 与 IO 的区别： IO是面向流的，NIO是面向缓冲区的； IO流是阻塞的，NIO流是不阻塞的; NIO有选择器，而IO没有。 读写数据方式： 从通道进行数据读取 ：创建一个缓冲区，然后请求通道读取数据。 从通道进行数据写入 ：创建一个缓冲区，填充数据，并要求通道写入数据。 文件java 文件操作的基础是 File/Path, 一个代表文件，一个代表路径，两者组合完整地描述各种操作系统中的文件，尤其适合 Linux 的‘Everything is a File’ 的哲学。 String -&gt; File （Write File）使用 NIO 的 Files (推荐)由于 Files 是 nio 在 java7 新增的内容，使用本方法需要首先将程序的 jdk 升级到 jdk7+; Files 工具类提供了各种读写创建删除文件等操作，可以很方便的操作文件和流。 如果写入的是字符数据，则需要设置字符编码 Charset 如果写入的是字节数据（byte[]），不需要设置字符编码 如果想在已存在的文件后追加内容，可以增加 java.nio.file.StandardOpenOption#APPEND 参数 DEMO 参考： String2FileWithJavaNioExample List&lt;String&gt; lines = Arrays.asList(&quot;The second line&quot;, &quot;The second line&quot;);Path path = Paths.get(&quot;filename.txt&quot;);try &#123; Files.write(path, lines, StandardCharsets.UTF_8);&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 使用 NIO 的 Channel标准的IO编程接口是面向字节流和字符流的。而NIO是面向通道和缓冲区的，数据总是从通道中读到buffer缓冲区内，或者从buffer写入到通道中。 Java NIO 的 Channel 和 IO 流的对比： 通道可以读也可以写，流一般来说是单向的（只能读或者写）。 通道可以异步读写。 通道总是基于缓冲区Buffer来读写。 DEMO 参考： String2FileWithJavaNioExample 使用 FileOutputStream 的 FileChannel： String data = &quot;The second line&quot; + System.getProperty(&quot;line.separator&quot;) + &quot;The second line&quot; + System.getProperty(&quot;line.separator&quot;);// use ByteBuffer wrap datafinal ByteBuffer buffer = ByteBuffer.wrap(data.getBytes());// try-with-resources auto close the channeltry (// open channel final FileOutputStream fos = new FileOutputStream(new File(&quot;filename.txt&quot;)); FileChannel channel = fos.getChannel()) &#123; // write buffer to channel while (buffer.hasRemaining()) &#123; channel.write(buffer); &#125;&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 使用 RandomAccessFile 的 FileChannel： String data = &quot;The second line&quot; + System.getProperty(&quot;line.separator&quot;) + &quot;The second line&quot; + System.getProperty(&quot;line.separator&quot;);final ByteBuffer buffer = ByteBuffer.wrap(data.getBytes());try(final RandomAccessFile file = new RandomAccessFile(&quot;filename.txt&quot;, &quot;rw&quot;); FileChannel channel = file.getChannel())&#123; while (buffer.hasRemaining())&#123; channel.write(buffer); &#125;&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 使用 BufferedWriter (推荐) BufferedWriter 可以设置缓存区大小 OutputStreamWriter 可以指定字符集编码 FileOutputStream 可以指定文件编辑模式(追加/覆盖) 使用 PrintWriter/FileWriter 一般写入的内容比较少，如果需要写入大量数据，应该要使用缓冲流，提高效率。 DEMO 参考： String2FileWithWriterExample try (Writer writer = new BufferedWriter(new OutputStreamWriter( new FileOutputStream(&quot;filename.txt&quot;, true), StandardCharsets.UTF_8))) &#123; writer.write(&quot;The second line&quot; + System.getProperty(&quot;line.separator&quot;) + &quot;The second line&quot; + System.getProperty(&quot;line.separator&quot;));&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 使用 PrintWrite使用PrintWrite可以很简单的使用println进行单行输入，但是存在的文件会被截断 如果文件已经存在，PrintWriter 会将文件大小截断为零，如果不想截断文件，可以使用FileWriter作为替代，FileWriter设置字符大小和缓冲大小。 使用 PrintWriter 不需要输入文件 path，所以创建文件的路径需要看执行程序时的工作目录。 PriteWriter 会导致吞异常，见 stackoverflow.com/a/1747092/4678667 。 DEMO 参考： String2FileWithWriterExample try (PrintWriter writer = new PrintWriter(&quot;filename.txt&quot;, &quot;UTF-8&quot;)) &#123; writer.println(&quot;The first line&quot;); writer.println(&quot;The second line&quot;);&#125; catch (FileNotFoundException | UnsupportedEncodingException e) &#123; e.printStackTrace();&#125; 使用 FileWriterFileWriter 在创建的时候可以指定追加/覆盖模式，避免 PrintWriter 截断已存在的文件。 DEMO 参考： String2FileWithWriterExample try (FileWriter writer = new FileWriter(new File(&quot;filename.txt&quot;), true)) &#123; writer.append(&quot;The first line&quot;).append(System.getProperty(&quot;line.separator&quot;)) .append(LINE2).append(System.getProperty(&quot;line.separator&quot;));&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 使用 commons-io 的 FileUtilsCommons-io 项目地址： apache/commons-io使用 commons-io 包中的 FileUtils 进行文件写入, 重构的方法可以设置文件编码和写入模式 DEMO 参考： String2FileWithCommonsExample try &#123; String data = &quot;The second line&quot; + System.getProperty(&quot;line.separator&quot;) + &quot;The second line&quot; + System.getProperty(&quot;line.separator&quot;); FileUtils.writeStringToFile(new File(&quot;filename.txt&quot;), data, StandardCharsets.UTF_8, true);&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 使用 guava 的 FilesGuava 的官方开源项目地址： google/guavaguava 的 Files 可以直接向文件中写入 byte[] 数据Files 已被标注为 @Beta 不稳定的版本，并提示使用 jdk7 nio 的 Files、MoreFiles 等工具类利用 nio 的 Path 进行文件处理 DEMO 参考： String2FileWithGuavaExample try &#123; String data = &quot;The second line&quot; + System.getProperty(&quot;line.separator&quot;) + &quot;The second line&quot; + System.getProperty(&quot;line.separator&quot;); Files.write(data.getBytes(), new File(&quot;filename.txt&quot;));&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 使用 guava 的 CharSink/ByteSinkguava 的 CharSink 可以直接向文件中写入字符数据，ByteSink 则可以写入字节数据Files 中的 write、append、copy 等方法本质上都是调用的这些 Sink 类。 DEMO 参考： String2FileWithGuavaExample try &#123; String data = &quot;The second line&quot; + System.getProperty(&quot;line.separator&quot;) + &quot;The second line&quot; + System.getProperty(&quot;line.separator&quot;); Files.asCharSink(new File(&quot;filename.txt&quot;), StandardCharsets.UTF_8, FileWriteMode.APPEND).write(data);&#125; catch (IOException e) &#123; e.printStackTrace();&#125; File -&gt; String (Read File)使用 NIO 的 Files (推荐)NIO 的 Files 工具类提供多种 read 方法可以快速进行文件读取 DEMO 参考： File2StringWithNioExample 使用 readAllBytes 读取字节： try &#123; return new String(Files.readAllBytes(Paths.get(&quot;filename.txt&quot;)));&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 使用 readAllLines 逐行读取字符串： try &#123; List&lt;String&gt; lines = Files.readAllLines(Paths.get(&quot;filename.txt&quot;), StandardCharsets.UTF_8); StringBuilder sb = new StringBuilder(); lines.forEach(s -&gt; sb.append(s).append(SEPARATOR)); return sb.toString();&#125; catch (IOException e) &#123; e.printStackTrace();&#125;return null; 由于 Stream 内部无法在 lambda 中使用带有 checked Exception 的方法，因此要对异常的抓取，防止发生异常 使用 lines 逐行读取字符串： try (Stream&lt;String&gt; lines = Files.lines(Paths.get(&quot;filename.txt&quot;), StandardCharsets.UTF_8)) &#123; StringBuilder content = new StringBuilder(); lines.forEach(s -&gt; content.append(s).append(SEPARATOR)); return content.toString();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 使用 ScannerScanner 默认的缓冲大小为 1024, 可以读取文件，但是读取空文件的时候会出现异常，见 Scanner的讨论 DEMO 参考： File2StringWithScannerExample try (Scanner scanner = new Scanner(new File(FILE_NAME_INPUT), &quot;UTF-8&quot;)) &#123; return scanner.useDelimiter(&quot;\\\\A&quot;).next();&#125; catch (FileNotFoundException e) &#123; e.printStackTrace();&#125; 使用 BufferedReader (推荐)BufferedReader 缓冲流，可以高效的读取文件，使用 Reader 和 InputStream 组合可以设置各种配置。 使用 InputStreamReader 可以设置字符集 使用 FileInputStream 可以读取文件 或者使用 FileReader 直接读取文件，并用 BufferedReader 包装成缓存使用 DEMO 参考： File2StringWithReaderExample // new BufferedReader(new FileReader(&quot;filename.txt&quot;));try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;filename.txt&quot;), StandardCharsets.UTF_8))) &#123; String line; StringBuilder stringBuilder = new StringBuilder(); while ((line = reader.readLine()) != null) &#123; stringBuilder.append(line).append(SEPARATOR); &#125; return stringBuilder.toString();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 使用 FileInputStream仅仅使用 FileInputStream 进行文件读取，从 FileInputStream 写入 byte[] 缓存，转换为文本数据，这段代码只需要 jdk1.0+ DEMO 参考： File2StringWithReaderExample FileInputStream fis = null;try &#123; fis = new FileInputStream(&quot;filename.txt&quot;); byte[] buffer = new byte[fis.available()]; int length = fis.read(buffer); return new String(buffer, 0, length, StandardCharsets.UTF_8);&#125; catch (IOException e) &#123; e.printStackTrace();&#125; finally &#123; if (fis != null) &#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;return null; 使用 commons-io 的 IOUtilscommons-io 的 IOUtils 工具类提供了大量 IO 相关的工具方法，使用 IOUtils.copy 直接将 Reader/InputStream 转换为 Writer/OutputStream DEMO 参考： File2StringWithCommonsExample 使用 FileReader 读取文件，使用 StringWriter 将流中的内容输出出来: try (FileReader fileReader = new FileReader(&quot;filename.txt&quot;); StringWriter stringWriter = new StringWriter()) &#123; IOUtils.copy(fileReader, stringWriter); return stringWriter.toString();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 使用 commons-io 的 FileUtilscommons-io 的 FileUtils 提供了文件相关的工具方法， 使用 FileUtils.readByFileUtilsReadFileToString 读取文件内容 DEMO 参考： File2StringWithCommonsExample try &#123; return FileUtils.readFileToString(new File(&quot;filename.txt&quot;), StandardCharsets.UTF_8);&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 使用 guava 的 Files直接使用 guava 的 Files 转换为 ByteSource/CharSource 然后直接 read 成字符串: try &#123; // Resources.asCharSource(new URL(&quot;&quot;), StandardCharsets.UTF_8).read(); return Files.asCharSource(new File(&quot;filename.txt&quot;), StandardCharsets.UTF_8).read();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 或者使用 readLines 逐行读取： try &#123; return String.join(System.getProperty(&quot;line.separator&quot;), Files.readLines(new File(&quot;filename.txt&quot;), StandardCharsets.UTF_8));&#125; catch (IOException e) &#123; e.printStackTrace();&#125; File -&gt; File (copy File)使用 NIO 的 Channel标准的IO编程接口是面向字节流和字符流的。而NIO是面向通道和缓冲区的，数据总是从通道中读到buffer缓冲区内，或者从buffer写入到通道中。 Java NIO 的 Channel 和 IO 流的对比： 通道可以读也可以写，流一般来说是单向的（只能读或者写）。 通道可以异步读写。 通道总是基于缓冲区Buffer来读写。 Buffer 及其子类不是线程安全的 Buffer 的属性： capacity - 缓存容量 limit - 缓存下表限制值 position - 当前操作的下标值 mark - 临时下标值 几个属性的关系： 0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity Buffer 的方法： mark(): mark 设置成 position clear(): mark 设置为 -1 清除标记, position 设置为 0, limit 设置为 capacity, 数据写入 Buffer 前调用 flip(): limit 设置成 position 当前位置作为上限, position 设置为 0, Buffer 读取数据前调用 rewind(): position 设置为 0, limit 不变, 数据重新写入 Buffer 前调用 使用不同的 Channel 同时操作同一个 Buffer 可以实现文件的复制。 DEMO 参考： File2FileWithNioExample try (FileInputStream input = new FileInputStream(&quot;filename.txt&quot;); FileOutputStream output = new FileOutputStream(&quot;filename.txt&quot;); ReadableByteChannel from = input.getChannel(); WritableByteChannel to = output.getChannel()) &#123; ByteBuffer buffer = ByteBuffer.allocateDirect(16 * 1024); while (from.read(buffer) != -1) &#123; // Prepare the buffer to be drained buffer.flip(); // Make sure that the buffer was fully drained while (buffer.hasRemaining()) &#123; to.write(buffer); &#125; // Make the buffer empty, ready for filling buffer.clear(); &#125;&#125; catch (IOException e) &#123; e.printStackTrace();&#125;","categories":[{"name":"编码","slug":"编码","permalink":"https://github.com/zzycreate/categories/编码/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://github.com/zzycreate/tags/Java/"},{"name":"java-convert-example","slug":"java-convert-example","permalink":"https://github.com/zzycreate/tags/java-convert-example/"},{"name":"File","slug":"File","permalink":"https://github.com/zzycreate/tags/File/"},{"name":"NIO","slug":"NIO","permalink":"https://github.com/zzycreate/tags/NIO/"}]},{"title":"mysql知识点收藏","slug":"mysql知识点收藏","date":"2019-04-06T16:25:15.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"2019/04/06/mysql知识点收藏/","link":"","permalink":"https://github.com/zzycreate/2019/04/06/mysql知识点收藏/","excerpt":"SQL 是后端程序员很重要的一个技能。","text":"SQL 是后端程序员很重要的一个技能。 /* Windows服务 */-- 启动MySQL net start mysql-- 创建Windows服务 sc create mysql binPath= mysqld_bin_path(注意：等号与值之间有空格)/* 连接与断开服务器 */mysql -h 地址 -P 端口 -u 用户名 -p 密码SHOW PROCESSLIST -- 显示哪些线程正在运行SHOW VARIABLES -- 显示系统变量信息/* 数据库操作 */ -------------------- 查看当前数据库 SELECT DATABASE();-- 显示当前时间、用户名、数据库版本 SELECT now(), user(), version();-- 创建库 CREATE DATABASE[ IF NOT EXISTS] 数据库名 数据库选项 数据库选项： CHARACTER SET charset_name COLLATE collation_name-- 查看已有库 SHOW DATABASES[ LIKE 'PATTERN']-- 查看当前库信息 SHOW CREATE DATABASE 数据库名-- 修改库的选项信息 ALTER DATABASE 库名 选项信息-- 删除库 DROP DATABASE[ IF EXISTS] 数据库名 同时删除该数据库相关的目录及其目录内容/* 表的操作 */ -------------------- 创建表 CREATE [TEMPORARY] TABLE[ IF NOT EXISTS] [库名.]表名 ( 表的结构定义 )[ 表选项] 每个字段必须有数据类型 最后一个字段后不能有逗号 TEMPORARY 临时表，会话结束时表自动消失 对于字段的定义： 字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT 'string']-- 表选项 -- 字符集 CHARSET = charset_name 如果表没有设定，则使用数据库字符集 -- 存储引擎 ENGINE = engine_name 表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同 常见的引擎：InnoDB MyISAM Memory/Heap BDB Merge Example CSV MaxDB Archive 不同的引擎在保存表的结构和数据时采用不同的方式 MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引 InnoDB表文件含义：.frm表定义，表空间数据和日志文件 SHOW ENGINES -- 显示存储引擎的状态信息 SHOW ENGINE 引擎名 &#123;LOGS|STATUS&#125; -- 显示存储引擎的日志或状态信息 -- 自增起始数 AUTO_INCREMENT = 行数 -- 数据文件目录 DATA DIRECTORY = '目录' -- 索引文件目录 INDEX DIRECTORY = '目录' -- 表注释 COMMENT = 'string' -- 分区选项 PARTITION BY ... (详细见手册)-- 查看所有表 SHOW TABLES[ LIKE 'pattern'] SHOW TABLES FROM 表名-- 查看表机构 SHOW CREATE TABLE 表名 （信息更详细） DESC 表名 / DESCRIBE 表名 / EXPLAIN 表名 / SHOW COLUMNS FROM 表名 [LIKE 'PATTERN'] SHOW TABLE STATUS [FROM db_name] [LIKE 'pattern']-- 修改表 -- 修改表本身的选项 ALTER TABLE 表名 表的选项 eg: ALTER TABLE 表名 ENGINE=MYISAM; -- 对表进行重命名 RENAME TABLE 原表名 TO 新表名 RENAME TABLE 原表名 TO 库名.表名 （可将表移动到另一个数据库） -- RENAME可以交换两个表名 -- 修改表的字段机构（13.1.2. ALTER TABLE语法） ALTER TABLE 表名 操作名 -- 操作名 ADD[ COLUMN] 字段定义 -- 增加字段 AFTER 字段名 -- 表示增加在该字段名后面 FIRST -- 表示增加在第一个 ADD PRIMARY KEY(字段名) -- 创建主键 ADD UNIQUE [索引名] (字段名)-- 创建唯一索引 ADD INDEX [索引名] (字段名) -- 创建普通索引 DROP[ COLUMN] 字段名 -- 删除字段 MODIFY[ COLUMN] 字段名 字段属性 -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上) CHANGE[ COLUMN] 原字段名 新字段名 字段属性 -- 支持对字段名修改 DROP PRIMARY KEY -- 删除主键(删除主键前需删除其AUTO_INCREMENT属性) DROP INDEX 索引名 -- 删除索引 DROP FOREIGN KEY 外键 -- 删除外键-- 删除表 DROP TABLE[ IF EXISTS] 表名 ...-- 清空表数据 TRUNCATE [TABLE] 表名-- 复制表结构 CREATE TABLE 表名 LIKE 要复制的表名-- 复制表结构和数据 CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名-- 检查表是否有错误 CHECK TABLE tbl_name [, tbl_name] ... [option] ...-- 优化表 OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...-- 修复表 REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM]-- 分析表 ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] .../* 数据操作 */ -------------------- 增 INSERT [INTO] 表名 [(字段列表)] VALUES (值列表)[, (值列表), ...] -- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。 -- 可同时插入多条数据记录！ REPLACE 与 INSERT 完全一样，可互换。 INSERT [INTO] 表名 SET 字段名=值[, 字段名=值, ...]-- 查 SELECT 字段列表 FROM 表名[ 其他子句] -- 可来自多个表的多个字段 -- 其他子句可以不使用 -- 字段列表可以用*代替，表示所有字段-- 删 DELETE FROM 表名[ 删除条件子句] 没有条件子句，则会删除全部-- 改 UPDATE 表名 SET 字段名=新值[, 字段名=新值] [更新条件]/* 字符集编码 */ -------------------- MySQL、数据库、表、字段均可设置编码-- 数据编码与客户端编码不需一致SHOW VARIABLES LIKE 'character_set_%' -- 查看所有字符集编码项 character_set_client 客户端向服务器发送数据时使用的编码 character_set_results 服务器端将结果返回给客户端所使用的编码 character_set_connection 连接层编码SET 变量名 = 变量值 SET character_set_client = gbk; SET character_set_results = gbk; SET character_set_connection = gbk;SET NAMES GBK; -- 相当于完成以上三个设置-- 校对集 校对集用以排序 SHOW CHARACTER SET [LIKE 'pattern']/SHOW CHARSET [LIKE 'pattern'] 查看所有字符集 SHOW COLLATION [LIKE 'pattern'] 查看所有校对集 CHARSET 字符集编码 设置字符集编码 COLLATE 校对集编码 设置校对集编码/* 数据类型（列类型） */ ------------------1. 数值类型-- a. 整型 ---------- 类型 字节 范围（有符号位） tinyint 1字节 -128 ~ 127 无符号位：0 ~ 255 smallint 2字节 -32768 ~ 32767 mediumint 3字节 -8388608 ~ 8388607 int 4字节 bigint 8字节 int(M) M表示总位数 - 默认存在符号位，unsigned 属性修改 - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改 例：int(5) 插入一个数'123'，补填后为'00123' - 在满足要求的情况下，越小越好。 - 1表示bool值真，0表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。-- b. 浮点型 ---------- 类型 字节 范围 float(单精度) 4字节 double(双精度) 8字节 浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。 不同于整型，前后均会补填0. 定义浮点型时，需指定总位数和小数位数。 float(M, D) double(M, D) M表示总位数，D表示小数位数。 M和D的大小会决定浮点数的范围。不同于整型的固定范围。 M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。 支持科学计数法表示。 浮点数表示近似值。-- c. 定点数 ---------- decimal -- 可变长度 decimal(M, D) M也表示总位数，D表示小数位数。 保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。 将浮点数转换为字符串来保存，每9位数字保存为4个字节。2. 字符串类型-- a. char, varchar ---------- char 定长字符串，速度快，但浪费空间 varchar 变长字符串，速度慢，但节省空间 M表示能存储的最大长度，此长度是字符数，非字节数。 不同的编码，所占用的空间不同。 char,最多255个字符，与编码无关。 varchar,最多65535字符，与编码有关。 一条有效记录最大不能超过65535个字节。 utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符 varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。 varchar 的最大有效长度由最大行大小和使用的字符集确定。 最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是64432-1-2=65532字节。 例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset=utf8; 问N的最大值是多少？ 答：(65535-1-2-4-30*3)/3-- b. blob, text ---------- blob 二进制字符串（字节字符串） tinyblob, blob, mediumblob, longblob text 非二进制字符串（字符字符串） tinytext, text, mediumtext, longtext text 在定义时，不需要定义长度，也不会计算总长度。 text 类型在定义时，不可给default值-- c. binary, varbinary ---------- 类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。 char, varchar, text 对应 binary, varbinary, blob.3. 日期时间类型 一般用整型保存时间戳，因为PHP可以很方便的将时间戳进行格式化。 datetime 8字节 日期及时间 1000-01-01 00:00:00 到 9999-12-31 23:59:59 date 3字节 日期 1000-01-01 到 9999-12-31 timestamp 4字节 时间戳 19700101000000 到 2038-01-19 03:14:07 time 3字节 时间 -838:59:59 到 838:59:59 year 1字节 年份 1901 - 2155datetime YYYY-MM-DD hh:mm:sstimestamp YY-MM-DD hh:mm:ss YYYYMMDDhhmmss YYMMDDhhmmss YYYYMMDDhhmmss YYMMDDhhmmssdate YYYY-MM-DD YY-MM-DD YYYYMMDD YYMMDD YYYYMMDD YYMMDDtime hh:mm:ss hhmmss hhmmssyear YYYY YY YYYY YY4. 枚举和集合-- 枚举(enum) ----------enum(val1, val2, val3...) 在已知的值中进行单选。最大数量为65535. 枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。 表现为字符串类型，存储却是整型。 NULL值的索引是NULL。 空字符串错误值的索引值是0。-- 集合（set） ----------set(val1, val2, val3...) create table tab ( gender set('男', '女', '无') ); insert into tab values ('男, 女'); 最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。 当创建表时，SET成员值的尾部空格将自动被删除。/* 选择类型 */-- PHP角度1. 功能满足2. 存储空间尽量小，处理效率更高3. 考虑兼容问题-- IP存储 ----------1. 只需存储，可用字符串2. 如果需计算，查找等，可存储为4个字节的无符号int，即unsigned 1) PHP函数转换 ip2long可转换为整型，但会出现携带符号问题。需格式化为无符号的整型。 利用sprintf函数格式化字符串 sprintf(\"%u\", ip2long('192.168.3.134')); 然后用long2ip将整型转回IP字符串 2) MySQL函数转换(无符号整型，UNSIGNED) INET_ATON('127.0.0.1') 将IP转为整型 INET_NTOA(2130706433) 将整型转为IP/* 列属性（列约束） */ ------------------1. PRIMARY 主键 - 能唯一标识记录的字段，可以作为主键。 - 一个表只能有一个主键。 - 主键具有唯一性。 - 声明字段时，用 primary key 标识。 也可以在字段列表之后声明 例：create table tab ( id int, stu varchar(10), primary key (id)); - 主键字段的值不能为null。 - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。 例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age));2. UNIQUE 唯一索引（唯一约束） 使得某字段的值也不能重复。3. NULL 约束 null不是数据类型，是列的一个属性。 表示当前列是否可以为null，表示什么都没有。 null, 允许为空。默认。 not null, 不允许为空。 insert into tab values (null, 'val'); -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null4. DEFAULT 默认值属性 当前字段的默认值。 insert into tab values (default, 'val'); -- 此时表示强制使用默认值。 create table tab ( add_time timestamp default current_timestamp ); -- 表示将当前时间的时间戳设为默认值。 current_date, current_time5. AUTO_INCREMENT 自动增长约束 自动增长必须为索引（主键或unique） 只能存在一个字段为自动增长。 默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 alter table tbl auto_increment = x;6. COMMENT 注释 例：create table tab ( id int ) comment '注释内容';7. FOREIGN KEY 外键约束 用于限制主表与从表数据完整性。 alter table t1 add constraint `t1_t2_fk` foreign key (t1_id) references t2(id); -- 将表t1的t1_id外键关联到表t2的id字段。 -- 每个外键都有一个名字，可以通过 constraint 指定 存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。 作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。 MySQL中，可以对InnoDB引擎使用外键约束： 语法： foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作] 此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。 可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。 如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择： 1. cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。 2. set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。 3. restrict，拒绝父表删除和更新。 注意，外键只被InnoDB存储引擎所支持。其他引擎是不支持的。/* 建表规范 */ ------------------ -- Normal Format, NF - 每个表保存一个实体信息 - 每个具有一个ID字段作为主键 - ID主键 + 原子表 -- 1NF, 第一范式 字段不能再分，就满足第一范式。 -- 2NF, 第二范式 满足第一范式的前提下，不能出现部分依赖。 消除符合主键就可以避免部分依赖。增加单列关键字。 -- 3NF, 第三范式 满足第二范式的前提下，不能出现传递依赖。 某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。 将一个实体信息的数据放在一个表内实现。/* SELECT */ ------------------SELECT [ALL|DISTINCT] select_expr FROM -&gt; WHERE -&gt; GROUP BY [合计函数] -&gt; HAVING -&gt; ORDER BY -&gt; LIMITa. select_expr -- 可以用 * 表示所有字段。 select * from tb; -- 可以使用表达式（计算公式、函数调用、字段也是个表达式） select stu, 29+25, now() from tb; -- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。 - 使用 as 关键字，也可省略 as. select stu+10 as add10 from tb;b. FROM 子句 用于标识查询来源。 -- 可以为表起别名。使用as关键字。 SELECT * FROM tb1 AS tt, tb2 AS bb; -- from子句后，可以同时出现多个表。 -- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。 SELECT * FROM tb1, tb2; -- 向优化符提示如何选择索引 USE INDEX、IGNORE INDEX、FORCE INDEX SELECT * FROM table1 USE INDEX (key1,key2) WHERE key1=1 AND key2=2 AND key3=3; SELECT * FROM table1 IGNORE INDEX (key3) WHERE key1=1 AND key2=2 AND key3=3;c. WHERE 子句 -- 从from获得的数据源中进行筛选。 -- 整型1表示真，0表示假。 -- 表达式由运算符和运算数组成。 -- 运算数：变量（字段）、值、函数返回值 -- 运算符： =, &lt;=&gt;, &lt;&gt;, !=, &lt;=, &lt;, &gt;=, &gt;, !, &amp;&amp;, ||, in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor is/is not 加上ture/false/unknown，检验某个值的真假 &lt;=&gt;与&lt;&gt;功能相同，&lt;=&gt;可用于null比较d. GROUP BY 子句, 分组子句 GROUP BY 字段/别名 [排序方式] 分组后会进行排序。升序：ASC，降序：DESC 以下[合计函数]需配合 GROUP BY 使用： count 返回不同的非NULL值数目 count(*)、count(字段) sum 求和 max 求最大值 min 求最小值 avg 求平均值 group_concat 返回带有来自一个组的连接的非NULL值的字符串结果。组内字符串连接。e. HAVING 子句，条件子句 与 where 功能、用法相同，执行时机不同。 where 在开始时执行检测数据，对原数据进行过滤。 having 对筛选出的结果再次进行过滤。 having 字段必须是查询出来的，where 字段必须是数据表存在的。 where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。 where 不可以使用合计函数。一般需用合计函数才会用 having SQL标准要求HAVING必须引用GROUP BY子句中的列或用于合计函数中的列。f. ORDER BY 子句，排序子句 order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]... 升序：ASC，降序：DESC 支持多个字段的排序。g. LIMIT 子句，限制结果数量子句 仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。 limit 起始位置, 获取条数 省略第一个参数，表示从索引0开始。limit 获取条数h. DISTINCT, ALL 选项 distinct 去除重复记录 默认为 all, 全部记录/* UNION */ ------------------ 将多个select查询的结果组合成一个结果集合。 SELECT ... UNION [ALL|DISTINCT] SELECT ... 默认 DISTINCT 方式，即所有返回的行都是唯一的 建议，对每个SELECT查询加上小括号包裹。 ORDER BY 排序时，需加上 LIMIT 进行结合。 需要各select查询的字段数量一样。 每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。/* 子查询 */ ------------------ - 子查询需用括号包裹。-- from型 from后要求是一个表，必须给子查询结果取个别名。 - 简化每个查询内的条件。 - from型需将结果生成一个临时表格，可用以原表的锁定的释放。 - 子查询返回一个表，表型子查询。 select * from (select * from tb where id&gt;0) as subfrom where id&gt;1;-- where型 - 子查询返回一个值，标量子查询。 - 不需要给子查询取别名。 - where子查询内的表，不能直接用以更新。 select * from tb where money = (select max(money) from tb); -- 列子查询 如果子查询结果返回的是一列。 使用 in 或 not in 完成查询 exists 和 not exists 条件 如果子查询返回数据，则返回1或0。常用于判断条件。 select column1 from t1 where exists (select * from t2); -- 行子查询 查询条件是一个行。 select * from t1 where (id, gender) in (select id, gender from t2); 行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...) 行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。 -- 特殊运算符 != all() 相当于 not in = some() 相当于 in。any 是 some 的别名 != some() 不等同于 not in，不等于其中某一个。 all, some 可以配合其他运算符一起使用。/* 连接查询(join) */ ------------------ 将多个表的字段进行连接，可以指定连接条件。-- 内连接(inner join) - 默认就是内连接，可省略inner。 - 只有数据存在时才能发送连接。即连接结果不能出现空行。 on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真） 也可用where表示连接条件。 还有 using, 但需字段名相同。 using(字段名) -- 交叉连接 cross join 即，没有条件的内连接。 select * from tb1 cross join tb2;-- 外连接(outer join) - 如果数据不存在，也会出现在连接结果中。 -- 左外连接 left join 如果数据不存在，左表记录会出现，而右表为null填充 -- 右外连接 right join 如果数据不存在，右表记录会出现，而左表为null填充-- 自然连接(natural join) 自动判断连接条件完成连接。 相当于省略了using，会自动查找相同字段名。 natural join natural left join natural right joinselect info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num = extra_info.stu_id;/* 导入导出 */ ------------------select * into outfile 文件地址 [控制格式] from 表名; -- 导出表数据load data [local] infile 文件地址 [replace|ignore] into table 表名 [控制格式]; -- 导入数据 生成的数据默认的分隔符是制表符 local未指定，则数据文件必须在服务器上 replace 和 ignore 关键词控制对现有的唯一键记录的重复的处理-- 控制格式fields 控制字段格式默认：fields terminated by '\\t' enclosed by '' escaped by '\\\\' terminated by 'string' -- 终止 enclosed by 'char' -- 包裹 escaped by 'char' -- 转义 -- 示例： SELECT a,b,a+b INTO OUTFILE '/tmp/result.text' FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"' LINES TERMINATED BY '\\n' FROM test_table;lines 控制行格式默认：lines terminated by '\\n' terminated by 'string' -- 终止/* INSERT */ ------------------select语句获得的数据可以用insert插入。可以省略对列的指定，要求 values () 括号内，提供给了按照列顺序出现的所有字段的值。 或者使用set语法。 INSERT INTO tbl_name SET field=value,...；可以一次性使用多个值，采用(), (), ();的形式。 INSERT INTO tbl_name VALUES (), (), ();可以在列值指定时，使用表达式。 INSERT INTO tbl_name VALUES (field_value, 10+10, now());可以使用一个特殊值 DEFAULT，表示该列使用默认值。 INSERT INTO tbl_name VALUES (field_value, DEFAULT);可以通过一个查询的结果，作为需要插入的值。 INSERT INTO tbl_name SELECT ...;可以指定在插入的值出现主键（或唯一索引）冲突时，更新其他非主键列的信息。 INSERT INTO tbl_name VALUES/SET/SELECT ON DUPLICATE KEY UPDATE 字段=值, …;/* DELETE */ ------------------DELETE FROM tbl_name [WHERE where_definition] [ORDER BY ...] [LIMIT row_count]按照条件删除。where指定删除的最多记录数。limit可以通过排序条件删除。order by + limit支持多表删除，使用类似连接语法。delete from 需要删除数据多表1，表2 using 表连接操作 条件。/* TRUNCATE */ ------------------TRUNCATE [TABLE] tbl_name清空数据删除重建表区别：1，truncate 是删除表再创建，delete 是逐条删除2，truncate 重置auto_increment的值。而delete不会3，truncate 不知道删除了几条，而delete知道。4，当被用于带分区的表时，truncate 会保留分区/* 备份与还原 */ ------------------备份，将数据的结构与表内数据保存起来。利用 mysqldump 指令完成。-- 导出mysqldump [options] db_name [tables]mysqldump [options] ---database DB1 [DB2 DB3...]mysqldump [options] --all--database1. 导出一张表 mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:/a.sql)2. 导出多张表 mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:/a.sql)3. 导出所有表 mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:/a.sql)4. 导出一个库 mysqldump -u用户名 -p密码 --lock-all-tables --database 库名 &gt; 文件名(D:/a.sql)可以-w携带WHERE条件-- 导入1. 在登录mysql的情况下： source 备份文件2. 在不登录的情况下 mysql -u用户名 -p密码 库名 &lt; 备份文件/* 事务(transaction) */ ------------------事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。 - 支持连续SQL的集体成功或集体撤销。 - 事务是数据库在数据晚自习方面的一个功能。 - 需要利用 InnoDB 或 BDB 存储引擎，对自动提交的特性支持完成。 - InnoDB被称为事务安全型引擎。-- 事务开启 START TRANSACTION; 或者 BEGIN; 开启事务后，所有被执行的SQL语句均被认作当前事务内的SQL语句。-- 事务提交 COMMIT;-- 事务回滚 ROLLBACK; 如果部分操作发生问题，映射到事务开启前。-- 事务的特性 1. 原子性（Atomicity） 事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 2. 一致性（Consistency） 事务前后数据的完整性必须保持一致。 - 事务开始和结束时，外部数据一致 - 在整个事务过程中，操作是连续的 3. 隔离性（Isolation） 多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。 4. 持久性（Durability） 一个事务一旦被提交，它对数据库中的数据改变就是永久性的。-- 事务的实现 1. 要求是事务支持的表类型 2. 执行一组相关的操作前开启事务 3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。-- 事务的原理 利用InnoDB的自动提交(autocommit)特性完成。 普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。 而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。-- 注意 1. 数据定义语言（DDL）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。 2. 事务不能被嵌套-- 保存点 SAVEPOINT 保存点名称 -- 设置一个事务保存点 ROLLBACK TO SAVEPOINT 保存点名称 -- 回滚到保存点 RELEASE SAVEPOINT 保存点名称 -- 删除保存点-- InnoDB自动提交特性设置 SET autocommit = 0|1; 0表示关闭自动提交，1表示开启自动提交。 - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要commit提交后才能持久化数据操作。 - 也可以关闭自动提交来开启事务。但与START TRANSACTION不同的是， SET autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接) 而START TRANSACTION记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务)/* 锁表 */表锁定只用于防止其它客户端进行不正当地读取和写入MyISAM 支持表锁，InnoDB 支持行锁-- 锁定 LOCK TABLES tbl_name [AS alias]-- 解锁 UNLOCK TABLES-- 字符连接函数concat(str1,str2,...])concat_ws(separator,str1,str2,...)-- 分支语句if 条件 then 执行语句elseif 条件 then 执行语句else 执行语句end if;-- 修改最外层语句结束符delimiter 自定义结束符号 SQL语句自定义结束符号delimiter ; -- 修改回原来的分号-- 语句块包裹begin 语句块end-- 特殊的执行1. 只要添加记录，就会触发程序。2. Insert into on duplicate key update 语法会触发： 如果没有重复记录，会触发 before insert, after insert; 如果有重复记录并更新，会触发 before insert, before update, after update; 如果有重复记录但是没有发生更新，则触发 before insert, before update3. Replace 语法 如果有记录，则执行 before insert, before delete, after delete, after insert/* SQL编程 */ --------------------// 局部变量 ------------ 变量声明 declare var_name[,...] type [default value] 这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个default子句。值可以被指定为一个表达式，不需要为一个常数。如果没有default子句，初始值为null。-- 赋值 使用 set 和 select into 语句为变量赋值。 - 注意：在函数内是可以使用全局变量（用户自定义的变量）--// 全局变量 ------------ 定义、赋值set 语句可以定义并为变量赋值。set @var = value;也可以使用select into语句为变量初始化并赋值。这样要求select语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。还可以把赋值语句看作一个表达式，通过select执行完成。此时为了避免=被当作关系运算符看待，使用:=代替。（set语句可以使用= 和 :=）。select @var:=20;select @v1:=id, @v2=name from t1 limit 1;select * from tbl_name where @var:=30;select into 可以将表中查询获得的数据赋给变量。 -| select max(height) into @max_height from tb;-- 自定义变量名为了避免select语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。@var=10; - 变量被定义后，在整个会话周期都有效（登录到退出）--// 控制结构 ------------ if语句if search_condition then statement_list[elseif search_condition then statement_list]...[else statement_list]end if;-- case语句CASE value WHEN [compare-value] THEN result[WHEN [compare-value] THEN result ...][ELSE result]END-- while循环[begin_label:] while search_condition do statement_listend while [end_label];- 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。 -- 退出循环 退出整个循环 leave 退出当前循环 iterate 通过退出的标签决定退出哪个循环--// 内置函数 ------------ 数值函数abs(x) -- 绝对值 abs(-10.9) = 10format(x, d) -- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46ceil(x) -- 向上取整 ceil(10.1) = 11floor(x) -- 向下取整 floor (10.1) = 10round(x) -- 四舍五入去整mod(m, n) -- m%n m mod n 求余 10%3=1pi() -- 获得圆周率pow(m, n) -- m^nsqrt(x) -- 算术平方根rand() -- 随机数truncate(x, d) -- 截取d位小数-- 时间日期函数now(), current_timestamp(); -- 当前日期时间current_date(); -- 当前日期current_time(); -- 当前时间date('yyyy-mm-dd hh:ii:ss'); -- 获取日期部分time('yyyy-mm-dd hh:ii:ss'); -- 获取时间部分date_format('yyyy-mm-dd hh:ii:ss', '%d %y %a %d %m %b %j'); -- 格式化时间unix_timestamp(); -- 获得unix时间戳from_unixtime(); -- 从时间戳获得时间-- 字符串函数length(string) -- string长度，字节char_length(string) -- string的字符个数substring(str, position [,length]) -- 从str的position开始,取length个字符replace(str ,search_str ,replace_str) -- 在str中用replace_str替换search_strinstr(string ,substring) -- 返回substring首次在string中出现的位置concat(string [,...]) -- 连接字串charset(str) -- 返回字串字符集lcase(string) -- 转换成小写left(string, length) -- 从string2中的左边起取length个字符load_file(file_name) -- 从文件读取内容locate(substring, string [,start_position]) -- 同instr,但可指定开始位置lpad(string, length, pad) -- 重复用pad加在string开头,直到字串长度为lengthltrim(string) -- 去除前端空格repeat(string, count) -- 重复count次rpad(string, length, pad) --在str后用pad补充,直到长度为lengthrtrim(string) -- 去除后端空格strcmp(string1 ,string2) -- 逐字符比较两字串大小-- 流程函数case when [condition] then result [when [condition] then result ...] [else result] end 多分支if(expr1,expr2,expr3) 双分支。-- 聚合函数count()sum();max();min();avg();group_concat()-- 其他常用函数md5();default();--// 存储函数，自定义函数 ------------ 新建 CREATE FUNCTION function_name (参数列表) RETURNS 返回值类型 函数体 - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。 - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。 - 参数部分，由\"参数名\"和\"参数类型\"组成。多个参数用逗号隔开。 - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。 - 多条语句应该使用 begin...end 语句块包含。 - 一定要有 return 返回值语句。-- 删除 DROP FUNCTION [IF EXISTS] function_name;-- 查看 SHOW FUNCTION STATUS LIKE 'partten' SHOW CREATE FUNCTION function_name;-- 修改 ALTER FUNCTION function_name 函数选项--// 存储过程，自定义功能 ------------ 定义存储存储过程 是一段代码（过程），存储在数据库中的sql组成。一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过call执行。-- 创建CREATE PROCEDURE sp_name (参数列表) 过程体参数列表：不同于函数的参数列表，需要指明参数类型IN，表示输入型OUT，表示输出型INOUT，表示混合型注意，没有返回值。/* 存储过程 */ ------------------存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。调用：CALL 过程名-- 注意- 没有返回值。- 只能单独调用，不可夹杂在其他语句中-- 参数IN|OUT|INOUT 参数名 数据类型IN 输入：在调用过程中，将数据输入到过程体内部的参数OUT 输出：在调用过程中，将过程体处理完的结果返回到客户端INOUT 输入输出：既可输入，也可输出-- 语法CREATE PROCEDURE 过程名 (参数列表)BEGIN 过程体END/* 用户和权限管理 */ -------------------- root密码重置1. 停止MySQL服务2. [Linux] /usr/local/mysql/bin/safe_mysqld --skip-grant-tables &amp; [Windows] mysqld --skip-grant-tables3. use mysql;4. UPDATE `user` SET PASSWORD=PASSWORD(\"密码\") WHERE `user` = \"root\";5. FLUSH PRIVILEGES;用户信息表：mysql.user-- 刷新权限FLUSH PRIVILEGES;-- 增加用户CREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串) - 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。 - 只能创建用户，不能赋予权限。 - 用户名，注意引号：如 'user_name'@'192.168.1.1' - 密码也需引号，纯数字密码也要加引号 - 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD-- 重命名用户RENAME USER old_user TO new_user-- 设置密码SET PASSWORD = PASSWORD('密码') -- 为当前用户设置密码SET PASSWORD FOR 用户名 = PASSWORD('密码') -- 为指定用户设置密码-- 删除用户DROP USER 用户名-- 分配权限/添加用户GRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] 'password'] - all privileges 表示所有权限 - *.* 表示所有库的所有表 - 库名.表名 表示某库下面的某表 GRANT ALL PRIVILEGES ON `pms`.* TO 'pms'@'%' IDENTIFIED BY 'pms0817';-- 查看权限SHOW GRANTS FOR 用户名 -- 查看当前用户权限 SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER();-- 撤消权限REVOKE 权限列表 ON 表名 FROM 用户名REVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名 -- 撤销所有权限-- 权限层级-- 要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user GRANT ALL ON *.*和 REVOKE ALL ON *.*只授予和撤销全局权限。数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host GRANT ALL ON db_name.*和REVOKE ALL ON db_name.*只授予和撤销数据库权限。表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv GRANT ALL ON db_name.tbl_name和REVOKE ALL ON db_name.tbl_name只授予和撤销表权限。列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv 当使用REVOKE时，您必须指定与被授权列相同的列。-- 权限列表ALL [PRIVILEGES] -- 设置除GRANT OPTION之外的所有简单权限ALTER -- 允许使用ALTER TABLEALTER ROUTINE -- 更改或取消已存储的子程序CREATE -- 允许使用CREATE TABLECREATE ROUTINE -- 创建已存储的子程序CREATE TEMPORARY TABLES -- 允许使用CREATE TEMPORARY TABLECREATE USER -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。CREATE VIEW -- 允许使用CREATE VIEWDELETE -- 允许使用DELETEDROP -- 允许使用DROP TABLEEXECUTE -- 允许用户运行已存储的子程序FILE -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILEINDEX -- 允许使用CREATE INDEX和DROP INDEXINSERT -- 允许使用INSERTLOCK TABLES -- 允许对您拥有SELECT权限的表使用LOCK TABLESPROCESS -- 允许使用SHOW FULL PROCESSLISTREFERENCES -- 未被实施RELOAD -- 允许使用FLUSHREPLICATION CLIENT -- 允许用户询问从属服务器或主服务器的地址REPLICATION SLAVE -- 用于复制型从属服务器（从主服务器中读取二进制日志事件）SELECT -- 允许使用SELECTSHOW DATABASES -- 显示所有数据库SHOW VIEW -- 允许使用SHOW CREATE VIEWSHUTDOWN -- 允许使用mysqladmin shutdownSUPER -- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。UPDATE -- 允许使用UPDATEUSAGE -- “无权限”的同义词GRANT OPTION -- 允许授予权限","categories":[{"name":"编码","slug":"编码","permalink":"https://github.com/zzycreate/categories/编码/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://github.com/zzycreate/tags/Mysql/"},{"name":"SQL","slug":"SQL","permalink":"https://github.com/zzycreate/tags/SQL/"}]},{"title":"再来一杯(Bilibili)","slug":"再来一杯-Bilibili","date":"2019-01-08T23:36:01.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"2019/01/08/再来一杯-Bilibili/","link":"","permalink":"https://github.com/zzycreate/2019/01/08/再来一杯-Bilibili/","excerpt":"[music~]","text":"[music~] 曾经我觉得我被世间遗忘没有人可以诉说苦闷和悲伤无法去理解人情世故炎凉分不清成长和伪装有什么两样无处不在的好奇和打量目光命令一般的关怀该如何抵抗突破重重的阻挡 撕破了所有的伪装终于来到这个地方 那些误解的 那些冲动的那些曾经年少情况每一次宣泄在悔恨后让人成长那些孤独的 那些迷茫的那些曾经无助彷徨每一次尝试在失败后更充满希望所有的苦痛烦恼忧愁与悲伤随着时间长河静静的流淌不间断地奔向远方 现在我觉得自己有了方向到处是令人兴奋和惊奇的景象第一次带着笑容进入梦乡每一天都是那么令人值得期望终于明白成长和伪装不一样已不必在意旁人不解的目光不再一个人流浪 有了专属的避风港漫长人生不再漫长 那些温暖的 那些热血的那些不自量力抵抗每一次在柔软后都更令人坚强那些快乐的 那些欢笑的那些无忧无虑时光每一滴泪水在感动后更充满力量所有美好的喜悦勇气和希望已经融入血液在体内流淌不断温暖我的胸膛 道路越是煎熬 就越坦然面对微笑风浪刮得越高 就要越心高气傲世界有太多美好等待寻找不切实际的梦才值得我们去燃烧～～ 那些离去的 那些消逝的并肩闯荡的过往感谢你曾经付出陪伴在我身旁那些关怀的 那些赞许的不断鞭策与鼓掌感谢你给我勇气黑暗中追逐光芒所有感情历经岁月后更闪亮让我们携手再次举杯歌唱未来一定就在前方 TIP: 2018bilibili新年MV《再来一杯》","categories":[{"name":"歌曲","slug":"歌曲","permalink":"https://github.com/zzycreate/categories/歌曲/"}],"tags":[{"name":"歌曲","slug":"歌曲","permalink":"https://github.com/zzycreate/tags/歌曲/"},{"name":"再来一杯","slug":"再来一杯","permalink":"https://github.com/zzycreate/tags/再来一杯/"},{"name":"Bilibili","slug":"Bilibili","permalink":"https://github.com/zzycreate/tags/Bilibili/"}]},{"title":"月色真美","slug":"月色真美","date":"2018-12-02T23:47:31.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"2018/12/02/月色真美/","link":"","permalink":"https://github.com/zzycreate/2018/12/02/月色真美/","excerpt":"","text":"As the moon, so beautiful 今夜の月は綺麗ですね 月色真美.jpg","categories":[{"name":"动画","slug":"动画","permalink":"https://github.com/zzycreate/categories/动画/"}],"tags":[{"name":"动画","slug":"动画","permalink":"https://github.com/zzycreate/tags/动画/"},{"name":"月色真美","slug":"月色真美","permalink":"https://github.com/zzycreate/tags/月色真美/"}]},{"title":"恶魔人 Crybaby","slug":"恶魔人-Crybaby","date":"2018-11-28T17:21:26.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"2018/11/28/恶魔人-Crybaby/","link":"","permalink":"https://github.com/zzycreate/2018/11/28/恶魔人-Crybaby/","excerpt":"《恶魔人 Crybaby》这部动画其实已经看了有几个月了，看过之后心情很复杂，整部动画故事叙述完整，有足够的矛盾冲突甚至可以说是太多了，人物塑造充分。这部作品是Netflix出品，汤浅政明导演，大河内一楼编剧，牛尾宪辅作曲的网络播放动画，全部一共十集，与 39 集的原作《恶魔人》动画相比，集数大幅缩减，汤浅政民在这种条件下完整的表现了他的恶魔人版本。本文涉及剧透，清酌情阅读。","text":"《恶魔人 Crybaby》这部动画其实已经看了有几个月了，看过之后心情很复杂，整部动画故事叙述完整，有足够的矛盾冲突甚至可以说是太多了，人物塑造充分。这部作品是Netflix出品，汤浅政明导演，大河内一楼编剧，牛尾宪辅作曲的网络播放动画，全部一共十集，与 39 集的原作《恶魔人》动画相比，集数大幅缩减，汤浅政民在这种条件下完整的表现了他的恶魔人版本。本文涉及剧透，清酌情阅读。 飞鸟了 &amp; 不动明 没有爱，不存在什么爱，所以也没有什么悲伤，我曾经这样认为。那个时候…我没能理解你到底在说什么。 ——飞鸟了 飞鸟了与不动明作为作品的两大主角，也是最终决战的双方；本来两人一直是好友的关系，但是因为双方理念的差异，最终导致了两者的对决。 不动明本来和恶魔没有任何关系，在听了飞鸟了讲述的恶魔的事情后，信任的选择帮助飞鸟了去揭露恶魔的存在，结果自身却被恶魔安蒙附身；由于不动明坚强的内心，仅凭自己的意志就压制了恶魔的意志，成为了一个拥有恶魔强大身体能力与人类善良纯真心灵的恶魔人。 而飞鸟了作为撒旦，喜欢的是简单直接的恶魔，讨厌着虚伪善变的人类，凭着几百万年来的印象，没有选择去理解人类这种生物，而是选择颠覆人类，让地球重回恶魔时代，再去与神明战斗。不动明是飞鸟了认可的人类，所以他安排了一开始的安息日活动，让明变成了恶魔人。 人类有着克服恐惧挺身出战的勇气，也有智慧和强大的武力，绝对可以和恶魔一较高下。 ———— 不动明为了杀掉那几百只恶魔，已经牺牲了数千万的人类，本来用来保护人类的武器，却也毁灭了不少人类。 ———— 飞鸟了 飞鸟了和不动明的冲突体现了汤浅政明想要表现的爱，了因为没有爱，所以没有任何悲伤的情感；在明死后，了感受到了悲伤，察觉到了自己对于明的爱，留下了悔恨的眼泪。 飞鸟了总是冷静的分析着客观事实，以整体的大局观去看待事物，因为对他来说，只要能完成自己的目的，可以使用任何手段，无论是在长崎光司（摄影师）家电脑中安装炸弹还是在田径大会上让幸田暴露恶魔身都是按照计划，没有任何意思犹豫，因此也就认为不存在爱。而不动明则会以来自己的想法，代入别人的立场去思考，会为别人的感情产生共鸣，会为别人而哭泣，会去思考恶魔是否有心灵，会去想着别人是否会悲伤哭泣。两者在爱的理解上有着本质的区别。 奔跑跑步是这次改编与原作差别比较大的点，作为田径部的美树、美子、明有着相互的羁绊，而作品中也提到了”人为什么要奔跑”这一问题。 为什么要奔跑？人再怎么跑，都比不上猫、狗甚至小鸟的身体能力，使用武器和载具才是人类最强的能力。 ————— 飞鸟了 人为何要奔跑，我不懂那些大道理，只是因为我喜欢，只要一点点，只要能向前进，我觉得只要能前进，就会有所改变，就算是微不足道的，一点点的进步，就算是一点点，一点点也可以… ————— 美树 人类的身体素质确实比不上其他很多动物，但是人类回去追求自身的极限，通过各种方式增强自身，想着自己想要实现的方向去前进。能够让自身都认可的成功不是靠简单的祈求，或者参加安息日这种迷信活动能够获得的，真正的成功应该是依靠自身的努力，一点一点的向前迈进才能达成的。","categories":[{"name":"动画","slug":"动画","permalink":"https://github.com/zzycreate/categories/动画/"}],"tags":[{"name":"动画","slug":"动画","permalink":"https://github.com/zzycreate/tags/动画/"},{"name":"恶魔人Crybaby","slug":"恶魔人Crybaby","permalink":"https://github.com/zzycreate/tags/恶魔人Crybaby/"},{"name":"netflix","slug":"netflix","permalink":"https://github.com/zzycreate/tags/netflix/"}]},{"title":"使用WSL在Windows中体验Linux","slug":"使用WSL在Windows中体验Linux","date":"2018-11-18T23:25:43.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"2018/11/18/使用WSL在Windows中体验Linux/","link":"","permalink":"https://github.com/zzycreate/2018/11/18/使用WSL在Windows中体验Linux/","excerpt":"微软在 Windows 10 中增加了 WSL 这个新功能，可以跑完整的 linux 镜像，而且不像虚拟机是应用层的实现需要消耗大量资源。现在 Windows 10 的商店里面提供了 Ubuntu、Debian、Kali Linux、OpenSUSE 等 linux 发行版。","text":"微软在 Windows 10 中增加了 WSL 这个新功能，可以跑完整的 linux 镜像，而且不像虚拟机是应用层的实现需要消耗大量资源。现在 Windows 10 的商店里面提供了 Ubuntu、Debian、Kali Linux、OpenSUSE 等 linux 发行版。 WSLWindows Subsystem for Linux (简称 WSL) 是为了能在 Windows10 上原生运行 Linux 二进制可执行文件 (ELF 可执行文件) 而制作的兼容层。这意味着在一些情况，不再需要使用 Linux 虚拟机、双系统、Cygwin/MSYS2 了，这样占用的资源会比虚拟机等方式要更省也更方便。 虽然WSL不是完整的Linux系统，但你依然可以做到绝大多数在完整Linux系统能做的事（比如vim, apt-get等）。 安装 WSL打开 Microsoft Store ，搜索 linux 可以看见已经有很多 linux 发行版支持可以使用 WSL。我选择了安装熟悉一些的 Ubuntu。 要使用 WSL 首选需要打开系统对 Linux 子系统的支持。 在开始菜单中或者小娜那里搜索“启用或关闭 Windows 功能”，打开对应的控制面板，勾选 “适用于 Linux 的 Windows 子系统”。 在 Microsoft Store 商店中下载安装 Ubuntu。 安装完毕之后，在开始菜单中会有 Ubuntu 的磁贴，点开磁铁，会出现命令行进行安装。 等待几分钟让系统自动安装 Ubuntu。 如果安装出现了错误，可以自行搜索一下错误码，我碰到过一次是因为网络问题，一次是系统更新，需要重启。 安装完成之后，输入 WSL 的用户名和密码，再打开 Ubuntu ，你会发现命令行已经是 bash 环境，可以直接使用 bash 的命令，使用方式就跟正常的 linux 一模一样。Ubuntu 可以使用 apt 包管理软件进行各种软件安装。 WSL 的文件系统在 WSL 中，你可以看到 Windows 的所有磁盘都挂载在 /mnt/ 下面，你在 Linux 下可以正常访问所有不需要系统权限的文件和文件夹。当然，需要注意的是，如果不是用的管理员账户，在 Linux 下使用 sudo 也无法访问需要 Windows 提升权限才能访问的文件。 同样，你在Windows下也可以看到WSL里的文件，但因为其使用了NTFS的软链接机制，如果你想让一个文件出现在你的Linux目录下，那你就必须在Linux下进行操作，在Win下操作之后，在Linux下仍然是看不到的。 在 C 盘创建一个 public 的文件夹，到 bash 中执行命令 ln -s /mnt/c/public ~/public 创建软链接，将 windows 和 WSL 中共享的文件都放在这个目录下，方便直接访问这个目录。 更新系统和软件可以直接使用 Ubuntu 的命令： sudo apt-get updatesudo apt-get upgrade# 升级系统到最新的 Ubuntu，注意：非常耗时，WSL 的磁盘 IO 效率很低sudo -S apt-mark hold procps strace sudosudo -S env RELEASE_UPGRADER_NO_SCREEN=1 do-release-upgrade 使用 ConEmu 替代 Windows 命令行Windows 的命令行，尤其是 CMD 显示效果和使用体验都非常差，PowerShell 相对来说还行，但是还是没有 Linux 下的终端那种爽快感。可以选择使用 ConEmu 或者 Cmder 进行替换，提升命令行使用体验。 我选择使用 ConEmu，安装完 ConEmu 之后，进入 Setting 设置中，点开左侧导航栏的 Startup &gt; Tasks。 新增一个 Task ，名称设置成 {Bash::Ubuntu}。 Command 命令框中输入： %windir%\\system32\\bash.exe ~ -cur_console:p，这样就可以使用 bash 直接进入用户的 home 目录。 在 ConEmu 的默认设置中选则 {Bash::Ubuntu} 作为启动的终端，可以在打开 ConEmu 时就能进入 bash 环境的使用。 使用 zsh 替换 bashWSL 不能直接将 bash 替换成 zsh，可以选择在打开 bash 的时候就直接跳转到 zsh 的环境。 首先安装 zsh sudo apt-get install zsh 安装 oh-my-zsh 提升 zsh 的体验，使用 oh-my-zsh 官网的推荐方式进行安装 # via curlsh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;# 或者# via wgetsh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot; 如果没有自动进入 zsh 的环境，可以执行 chsh -s zsh bash 执行即调用 zsh，修改 ~/.bashrc 在最后面加入一下内容： if test -t 1; thenexec zshfi 按个人配置 zsh，我习惯使用 ys 主题，直接修改 ~/.zshrc 进行主题插件的配置。 WSL 管理配置Windows10 自带了 wslconfig，去管理多个安装的发行版，比如卸载某个发行版，设置默认启动的发型版。 在PowerShell中输入 wslconfig /?， 可以看到: PS D:\\&gt; wslconfig /?在 Linux Windows 子系统上执行管理操作用法: /l, /list [/all] - 列出已注册的分发内容。 /all - 有选择地列出所有分发内容，包括目前 正安装或未安装的分发内容。 /s, /setdefault &lt;DistributionName&gt; - 将指定的分发内容设置为默认值。 /u, /unregister &lt;DistributionName&gt; - 注销分发内容。 切换默认发行版: PS D:\\&gt; wslconfig /l# 适用于 Linux 的 Windows 子系统:Legacy (默认)UbuntuPS D:\\&gt; wslconfig /s UbuntuPS D:\\&gt; wslconfig /l# 适用于 Linux 的 Windows 子系统:Ubuntu (默认)Legacy 在Windows 1803 后，还支持更多配置。比如网络，root 目录等。进入发行版后， 可以在 /etc/wsl.conf 中配置。 如果没有该文件，可以手动创建一个配置: [automount]enabled = true # 自动挂载 c:/ 等到 /mntroot = /windir/options = &quot;metadata,umask=22,fmask=11&quot;mountFsTab = false[network]generateHosts = truegenerateResolvConf = true WSL 交互也是从1709开始，WSL支持在Windows 10上直接使用 Linux命令: PS D:\\test&gt; wsl ls -latotal 5836drwxrwxrwx 1 root root 4096 Jan 25 13:20 .drwxrwxrwx 1 root root 4096 Apr 20 16:25 ..-rwxrwxrwx 1 root root 105 Oct 14 2017 03-build.ps1 同样在 WSL 内也可以使用Windows应用程序，比如notepad，docker： root@mushroom:/mnt/d/go/src/code.teambition.com/soa/webhooks# docker.exe psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES63698edb01a8 quay.io/coreos/etcd:latest &quot;/usr/local/bin/etcd&quot; 2 days ago Up 27 hours 0.0.0.0:2379-&gt;2379/tcp, 2380/tcp etcd 这是个非常赞的特性，极大方便了开发者。但在使用过程中发现，有个体验非常不好的地方，必须带.exe后缀才行，不然会提示找不到命令 : root@mushroom:/mnt/d/go/src/code.teambition.com/soa/webhooks# dockerThe program &apos;docker&apos; is currently not installed. You can install it by typing:apt-get install docker 比如在别的 linux 系统上写了个 docker build 的脚本，放到 Windows 上后 想使用 WSL 去执行，发现必须加后缀才行，这样脚本就没办法统一了。 参考文章： WSL与Windows交互实践 Windows Subsystem for Linux (WSL) 最佳实践指南! 简明的WSL教程","categories":[{"name":"系统","slug":"系统","permalink":"https://github.com/zzycreate/categories/系统/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/zzycreate/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://github.com/zzycreate/tags/Ubuntu/"},{"name":"WSL","slug":"WSL","permalink":"https://github.com/zzycreate/tags/WSL/"},{"name":"Windows","slug":"Windows","permalink":"https://github.com/zzycreate/tags/Windows/"}]},{"title":"使用nvm安装nodejs","slug":"使用nvm安装nodejs","date":"2018-11-07T00:06:25.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"2018/11/07/使用nvm安装nodejs/","link":"","permalink":"https://github.com/zzycreate/2018/11/07/使用nvm安装nodejs/","excerpt":"","text":"nodejs 的安装通常的做法是到官网上直接下载最新版本的程序，然后进行安装，这样的安装方式可以说是很正确；但是 nodejs 是一个快速更新的语言，版本更新非常快，很可能有会出现版本问题导致某些包使用时发生异常，这时候要卸载安装或者覆盖更新都是很蛋疼的一件事。为了快速切换 node 版本，Node Version Manager 应运而生。 NVMnvm 的是 github 上的一个项目，项目地址： creationix/nvm nvm 项目不支持 Windows (#284)，如果是在 Windows 环境下使用，官方推荐的项目：coreybutler/nvm-windows 或者 nullivex/nodist. nvm 的安装nvm 官方提供了执行脚本。 cURL: curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash Wget: wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash The script clones the nvm repository to ~/.nvm and adds the source line to your profile (~/.bash_profile, ~/.zshrc, ~/.profile, or ~/.bashrc).这个脚本会把 nvm 的资源加载到 ~/.nvm 并向环境变量 (~/.bash_profile, ~/.zshrc, ~/.profile, or ~/.bashrc) 中写入一下内容： export NVM_DIR=&quot;$&#123;XDG_CONFIG_HOME/:-$HOME/.&#125;nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm 如果要自定义 source, directory, profile 和 version 的值，需要使用对应的参数: NVM_SOURCE, NVM_DIR, PROFILE, and NODE_VERSION 。 如果安装后提示找不到指令，尝试重启终端，source 环境变量等方法。 nvm 的使用下载、编译、安装最新版本的 nodejs: nvm install node安装制定版本的 nodejs: nvm install 6.14.4列举可用版本: nvm ls-remote使用 nodejs: nvm use node 这些命令中，node 指代最新版本的 nodejs, 也可以替换成 iojs、 stable(稳定版)、unstable(开发版) 或者指定的版本号。 官方文档中对各种命令进行了列举，文档说明比较清晰，而且功能也比较简单，各位可以自行尝试。 nvm-windowsnvm-windows 和 nvm 的命令有一些区别，不过大体上是一致的。 nvm-windows 的安装在项目 release页面 可以直接下载已经发布的版本。 安装过程中会提示选择两个地址，一个是 nvm 程序的安装地址，一个是 nodejs 的安装地址。安装路径中不要含有中文，避免中文路径导致的错误。 安装完成后，使用 nvm v 查看 nvm 版本号，可以检查是否安装成功。 如果没有安装成功，可能需要在系统环境变量中配置 %NVM_HOME% 和 %NVM_SYMLINK% 这两个环境变量 安装 npm有时候 npm 的官方地址无法访问，这时候就需要设置国内的镜像源。 nvm 路径下有个 setting.txt 文件，文件后面添加下面的内容进行 nodejs 和 npm 的镜像地址配置。 node_mirror: https://npm.taobao.org/mirrors/node/npm_mirror: https://npm.taobao.org/mirrors/npm/ 安装 node使用 nvm 安装 nodejs: nvm install latest # 安装最新nvm install 11.1.0 # 安装指定版本nvm install 10.0.0 32 # 安装 32 位的系统的版本 对应的卸载命令就是 nvm uninstall 11.1.0 安装完了之后还无法使用 node 和 npm 命令，因为还没有制定使用哪个 nodejs: nvm use 8.0.0 其实 use 只是将 nvm 安装路径下下载的对应版本 nodejs 的目录超链接到上文安装 nvm-windows 时选择的 node 路径处。 这样环境变量 %NVM_SYMLINK% 指向的最终路径就会是 nvm use 的 nodejs 版本路径。 使用 nvm use 就可以快速切换 nodejs 版本。 npmnpm 的一些使用方法。 设置 npm 的全局安装路径使用 npm config 进行设置的配置： npm config set prefix &quot;E:\\nodejs\\npm-global&quot; 这样配置之后，使用 npm install -g 安装的全局包就都会下载到制定的仓库目录下。这个命令会在用户文件夹的 ~/.npmrc 文件中写入 prefix=E:\\nodejs\\npm-global 的数据。 但是下载的这些全局包可能不能直接使用对应的命令，这是因为系统环境变量的问题。 我选择在环境变量里面新定义一个变量 NPM_MODULES, 然后在 Path 中添加 %NPM_MODULES%; 变量，这样全局安装的 npm 包，就会加入到环境变量中，可以直接使用对应的命令。 使用 nvm 安装的 nodejs 都会有各自的 npm 包管理程序，所以如果你使用了 nvm use 进行 nodejs 的切换，上面 npm config 的配置就会变更，全局仓库就会失效了，所以一定记得在 nvm use 之后要重新设置 npm config 配置全局仓库地址。 npm 下载慢的解决方法npm 直接连官方源是比较慢的，甚至有可能被墙，所以需要更换 npm 源。 一种方式是 npm config set registry url 进行注册地址的变更。 还有一种是安装 cnpm， 其实不太推荐这种，cnpm 可能会导致一些奇怪的问题。 另外还推荐使用 nrm 这个包进行源的切换，这个包可以对多个注册源进行测试，方便你选择最合适的注册源。 我另外一片文章中记录了这个内容，文章地址：npm下载慢的解决方法 参考文章： nvm README Windows下安装nvm、npm及node.js Windows 下安装 nvm 管理 nodejs 版本","categories":[{"name":"编码","slug":"编码","permalink":"https://github.com/zzycreate/categories/编码/"}],"tags":[{"name":"node","slug":"node","permalink":"https://github.com/zzycreate/tags/node/"},{"name":"npm","slug":"npm","permalink":"https://github.com/zzycreate/tags/npm/"},{"name":"nvm","slug":"nvm","permalink":"https://github.com/zzycreate/tags/nvm/"}]},{"title":"Manjaro的尝试","slug":"Manjaro的尝试","date":"2018-11-03T14:14:12.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"2018/11/03/Manjaro的尝试/","link":"","permalink":"https://github.com/zzycreate/2018/11/03/Manjaro的尝试/","excerpt":"linux 拥有大量的发行版，虽然都是使用的相同的 linux kernel，但是由于 linux 下软件的繁多，各种不同的发行版有着不同的软件组合和生态。大众常用的几个发行版主要有 RedHat、Fedora、CentOS、Ubuntu 等。最近发现了 ArchLinux 分支下据说最好的版本 ———— Manjaro，对其进行一番尝试。","text":"linux 拥有大量的发行版，虽然都是使用的相同的 linux kernel，但是由于 linux 下软件的繁多，各种不同的发行版有着不同的软件组合和生态。大众常用的几个发行版主要有 RedHat、Fedora、CentOS、Ubuntu 等。最近发现了 ArchLinux 分支下据说最好的版本 ———— Manjaro，对其进行一番尝试。 Manjaro 的安装Manjaro 介绍 Manjaro是一款基于Arch Linux、对用户友好、全球排名第1的Linux发行版。（排名数据源于 DistroWatch，统计日期2018.03.02，时间段3个月。）Manjaro 的官网是 https://manjaro.org/. 在 Linux 圈，Arch 的确是一个异常强大的发行版。它有3个无与伦比的优势： 滚动更新可以使软件保持最新； AUR 软件仓库有着世界上最齐全的 Linux 软件； 丰富的 wiki 和活跃的社区让所有问题都可以快速得到满意的答案。 作为准备折腾的玩物，Arch Linux 这些特性很吸引我。Arch Linux 被人诟病的最多的就是对新手不友好，安装复杂。Manjaro 的出现就是为了解决 Arch Linux 的一些操作上的不舒适。 Manjaro 下载Manjaro 官方下载地址 https://manjaro.org/get-manjaro/.另外国内的一些下载站点也提供下载：中科大镜像站、清华大学镜像站 Manjaro 官网提供了三种版本，分别对应了三种 linux 桌面集成版本。 Manjaro XFCE版: Xfce是一个用于类UNIX操作系统的轻量级桌面环境。 它的目标是快速和系统资源低耗，同时仍然保持视觉上的吸引力和对用户友好的特性。 Manjaro KDE版: KDE是一个功能丰富多样的桌面环境，提供几种不同风格的菜单来访问应用程序。还有一个优秀的内置界面，可以方便地访问、下载、安装新的主题、小部件等。 虽然在用户友好度上做的非常好，但KDE也是相当消耗系统资源的，跟XFCE比较起来，启动程序、使用桌面环境都明显偏慢。运行Manjaro的64位KDE桌面使用大约需要550MB的内存。 Manjaro GNOME版: GNOME 桌面环境是作为 GNU 项目的一部分来开发的，它旨在简单易用，并且完全可用。 它的默认显示服务器是 Wayland。 虽然外观是独特的，它的可定制性仍然非常高。各种扩展可以从https://extensions.gnome.org/获取。像KDE一样，它比Xfce使用更多的资源。 就界面的操作逻辑来说，XFCE 类似于 Win7，KDE 类似于 Win10，Gnome 类似于 Ubuntu。 我选择先使用 KDE 版本尝试一番。 已经更换为 gnome 主题，后文所有的内容都适用于 gnome，安装的图片还是 kde 的图片，我就不换了，注意桌面系统的区别。 Manjaro 安装使用 VirtualBox 进行安装。 manjaro-install1.png 专家模式，类型 Linux，版本 Arch Linux（64-bit），内存 2048 MB。 manjaro-install2.png 文件大小 50 GB，虚拟硬盘文件类型 VDI，文件位置 自选。 manjaro-install3.png manjaro-install4.png 选择语言，按 方向→ ，选择中文、zh_CN； Boot: Manjaro.x86_64 kde ，按方向→ 进入安装程序。 manjaro-install5.png Launch at start 可以选择关闭，按 Launch installer 或者双击桌面的 Install Manjaro 进入安装步骤。 选择语言键盘，图略。选择 简体中文（中国） ，时区选择 Asia - Shanghai ，键盘 Chinese。 manjaro-install6.png 手动分区，注意此处左上角的 BIOS ，一些同学可能是EFI方式安装的。 manjaro-install7.png 新建分区表，BIOS 引导方式选择 MBR 分区表，EFI 引导方式选择 FPT 分区表。 然后对空闲空间进行分区。 manjaro-install8.png 我制作的分区最终为： 挂载点：/ ，大小：36362 MiB，分区类型：主分区 ，文件类型：ext4 ， 标记：无所谓 选 root；用于根节点挂载 挂载点：/boot ，大小：500 MiB，分区类型：主分区 ，文件类型：ext4 ， 标记：无所谓 选 boot ；用于系统引导挂载 挂载点：/home ，大小：10240 MiB，分区类型：主分区 ，文件类型：ext4 ， 标记：无所谓 选 root ，用于用户目录挂载 分区类型：拓展分区 ，文件类型：ext4 ， 标记：无所谓 选 swap ；在这个拓展分区下新建分区：挂载点：/swap，大小：4096 MiB，分区类型：逻辑分区 ，文件类型：linuxswap ， 标记：无所谓 选 swap ，用于内存缓存恢复，一般为内存的两倍大小 manjaro-install9.png 下一步选择创建用户，最后一行是创建 root 用户的密码，一定要记住。继续后面的步骤完成安装。 Manjaro 软件折腾软件源自动方式Manjaro 的默认软件源在国外，速度一般不理想，需要更换国内更快的源。 使用 F12 可以使用下拉的 Terminal ，快速开启 bash 的命令行环境。 使用以下命令进行软件源的排列： sudo pacman-mirrors -g 或者使用以下命令直接测试中文源的速度，会弹出弹窗，可以进行勾选。 sudo pacman-mirrors -i -c China -m rank manjaro-install10.png 直接选择速度同步时间段，速度快的源。 手动方式换源选择手动修改软件源。 sudo vi /etc/pacman.conf 编辑 /etc/pacman.config ，在最底部添加以下描述（中科大源）： [archlinuxcn]SigLevel = Optional TrustedOnlyServer = https://mirrors.ustc.edu.cn/archlinuxcn/$archServer = http://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch 然后更新源： sudo pacman -Syy &amp;&amp; sudo pacman -S archlinuxcn-keyring 软件安装的方式pacman -S package_name1 package_name2 ... # 安装软件pacman -R package_name # 删除软件pacman -Syu # 更新软件和系统pacman -Ss string1 string2 ... # 搜索 其他也可以添加 yaourt ，这个也是一个 Manjaro 上常用的包管理命令，使用上差不多。安装： pacman -S base-devel yaourt yaourt 已经被官方标记为 inactive，可以尝试使用 yay 或者 aurman 作为 AUR 包管理， 看了一下 github ，yay 的更新会更新一些，所以我选择装一个 yay 作为 AUR 的包管理，这样可以使用 AUR 源里的软件。yay 的 github 仓库地址： https://github.com/Jguer/yay 安装方式： git clone https://aur.archlinux.org/yay.gitcd yaymakepkg -si yay 使用方法基本和 pacman 一致，一些定制用法： yay &lt;Search Term&gt; Present package-installation selection menu.yay -Ps Print system statistics.yay -Yc Clean unneeded dependencies.yay -G &lt;AUR Package&gt; Download PKGBUILD from ABS or AUR.yay -Y --gendb Generate development package database used for devel update.yay -Syu --devel --timeupdate Perform system upgrade, but also check for development package updates and use PKGBUILD modification time (not version number) to determine update. 输入法Manjaro 默认有中文输入，但是使用和管理不方便，需要进行一些配置，常用的是使用 fcitx 或者 iBus 进行输入法的管理。Linux 上输入法是各大坑，需要一些尝试，我选择使用 fcitx 进行尝试。 安装 fcitx 主程序，并安装 fcitx-toolconfig 的配置管理程序： sudo pacman -S fcitx-imsudo pacman -S fcitx-configtool 安装完 fcitx 的程序，需要进行配置，使用 sudo vi ~/.xprofile 进行配置修改，添加以下内容。 export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=\"@im=fcitx\" 中文输入法其实有很多，主要是使用的 搜狗输入法（fcitx-sogoupinyin）、谷歌输入法（fcitx-googlepinyin）,sun拼音（fcitx-sunpinyin），另外还有 fcitx-cloudpinyin 可以进行云词库的搜索。 sudo pacman -S fcitx-sogoupinyin 或者 yaourt sogousudo pacman -S fcitx-googlepinyinsudo pacman -S fcitx-sunpinyinsudo pacman -S fcitx-cloudpinyin manjaro-software1.png 如果还是无法使用，可能需要安装fcitx-gtk2: sudo pacman -S fcitx-gtk2 第一个为非激活状态，一般选择 键盘-汉语 ， 后面选择其他输入法，这样就可以使用 Ctrl+Space 进行键盘和输入法的切换（非激活状态与激活状态切换），激活状态可以使用 Ctrl+Shift 进行输入法的切换，很方便。 fcitx 配置可以修改快捷键，Ctrl + Space 可能会和 Jetbrains 系列产生冲突，建议修改成 Ctrl + , 或者 Super + Space。 对于 jetbrians 系列 fcitx 无法跟随的情况 fcitx输入法配置&gt;附加组件&gt;勾选高级&gt;xim前端&gt;勾选on the spot Chrome使用 pacman 进行 Chrome 的安装也很简单，使用命令： sudo pacman -S google-chrome 或者安装 chromium: sudo pacman -S chromium 中文汉化firefox-i18n-zh-cn : 火狐浏览器中文汉化thunderbird-i18n-zh-cn : thunderbird 邮件汉化gimp-help-zh_cn :libreoffice-still-zh-CN : libreoffice 汉化man-pages-zh_cn : man 帮助文档汉化 sudo pacman -S --noconfirm firefox-i18n-zh-cn thunderbird-i18n-zh-cn gimp-help-zh_cn libreoffice-still-zh-CN man-pages-zh_cn 火狐中文包安装完之后，在火狐的菜单中选择 add-ons 检查中文包是否安装完好；如果已经包含了，在地址栏中输入 about:config 。搜索 intl.locale.requested， 如果没有，则右键新建一个，修改值为 zh_CN，重启。 Zsh安装 oh-my-zsh 作为 shell : sudo pacman -S zsh gitsh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;chsh -s /bin/zsh 或者使用 aur 中 oh-my-zsh-git 的软件包，一键安装。 sudo pacman -S zshsudo pacman -S oh-my-zsh-gitcp /usr/share/oh-my-zsh/zshrc ~/.zshrc #ohmyzsh配置文件chsh -s /bin/zsh #替换默认shell Vimvim 是 vi 的增强编辑器，功能强大 sudo pacman -S vim oracle jdk系统自带了 openjdk ，但是还是想使用 oracle jdk，使用命令 yay -S jdk8 即可安装 oracle 的 jdk8, 安装的 jdk 位置是 /usr/lib/jvm/java-8-jdk/bin/java, 默认的 openjdk 位置是 /usr/lib/jvm/default 但是这样安装之后 java --version 还是显示的 OpenJDK。 使用 archlinux-java 命令进行jdk的选择，archlinux-java 的说明见：Java ArchWiki、或者 Java ArchWIki(简体中文)) archlinux-java &lt;COMMAND&gt;COMMAND: status List installed Java environments and enabled one get Return the short name of the Java environment set as default set &lt;JAVA_ENV&gt; Force &lt;JAVA_ENV&gt; as default unset Unset current default Java environment fix Fix an invalid/broken default Java environment configuration Maven安装 maven 作为 java 项目的包管理软件，执行命令 yay -S maven。maven 安装路径为：/opt/maven。 执行 cp /opt/maven/conf/setting.xml ~/.m2/ 拷贝全局配置到当前用户目录，修改 .m2 目录中的配置文件进行个人配置修改。 QQGnome 桌面的 Manjaro 可用，KDE 桌面的 Manjaro 我试用时，无法使用，以下内容先记录下来 TIM 是腾讯旗下的聊天工具 QQ 的新版设计，腾讯官方已经在 2010 年停止了 Linux 版的 QQ 更新，wine 版的 QQ是网友制作并维护的 Linux 版 QQ，不过也在 2017 年停止了更新，于是 deepin 公司维护了一个 deepin wine 系列软件，包括 QQ。 deepin：如果您用的是 deepin，deepinwine 的 QQ 默认就已经安装。 Arch系：如果您用的是 archlinux/antergos/manjaro，可以用 yaourt 命令安装它。manjaro 默认就开启了 AUR，在 pamac 图形管理器上搜 deepin office，然后切换到 AUR 标签，出来几种可用的 deepin wine包， deepin 粉丝 wszqkzqk 最开始移植的 deepin.com.qq.office 和 deepin.com.qq.im。最新的还有 countstarlight 移植的2.0的 tim 版本。 sudo pacman -S deepin.com.qq.officesudo pacman -S deepin.com.qq.im manjaro-software2.png 虽然我在 Octopi 中找到了这两个包，也安装成功了，但是实际上 QQ 并不能打开成功，有待后续继续研究。 微信微信安装的是 electronic-wechat-git: sudo pacman -S electronic-wechat-git PDF 阅读器可以使用强大的福昕PDF阅读器，或者使用小巧的 evince 。如果只是阅读，evince 已经够用了。 yay -S foxitreaderyay -S evince 笔记工具cherrytree 是一个以节点为管理元素的笔记软件，小巧轻便，还可以加密，推荐使用。另外的为知笔记(wiznote)、蚂蚁笔记(leanote), 也都是使用比较广泛的笔记软件。 yay -S cherrytree 截图工具安装截图工具 xfce4-screenshooter: sudo pacman -S xfce4-screenshooter 设置快捷键, &gt;键盘&gt;应用程序快捷键，添加快捷键，命令为 xfce4-screenshooter -f 或者安装深度的截图工具 deepin-screenshot: sudo pacman -S deepin-screenshot 设置快捷键, &gt;键盘&gt;应用程序快捷键，添加快捷键，命令为 deepin-screenshot deepin 的截图和 windows 下一般的截图工具操作体验一致，比较推荐。 Guake/Tilda/yakuakeManjaro KDE 系统默认是有快速下拉的终端 Yakuake， xcef 和 Gnome 版没有，可以安装 Guake 或者 Tilda 实现相同功能。 sudo pacman -S tildasudo pacman -S guake tilda 默认是左上角显示，使用快捷键 F1；Guake 默认是顶部显示，快捷键 F12。可以使用快捷键，快速打开终端输入命令。 快速搜索类似于 Mac 上的 Alfred，快速搜索，可以自行在配置中添加快捷键。不是使用体验只能说还行，Gnome 自带的搜索其实也可以做到很多事情的，快捷键 Super + A。对 synapse 有兴趣的可以尝试一下。 yay -S synapse 另外还有个类似功能的软件叫 Albert yay -S albert 建议 albert 使用加快捷方式的办法，快捷方式的命令使用 albert toggle 或者 albert show。使用应用内的快捷方式实在是不怎么可靠。 albert 相对于 synapse 界面要素雅一点，synapse 可以在界面上就控制你搜索的类型。 albert 的自定义快捷命令用于搜索引擎的快速使用深得我心，synapse 找了半天没法自定义网页搜索。 剪切板管理 copyq类似于 Ditto，监控管理剪切板。 yay -S copyq 开发工具开发 java 使用 IDEA .开发其他脚本语言，例如 javascript, 使用 vscode .连接数据库使用 dbeave (非常强大，Mysql、Oracle应有尽有) # 社区版 IDEAyay -S intellij-idea-community-edition# 商业版 IDEAyay -S intellij-idea-ultimate-edition# vscodeyay -S visual-studio-code# dbeaveryay -S dbeaver gnome 主题美化我选择的 gnome 桌面主题组合是主题 Mc-OS-themes 、图标 la-capitaine-icon-theme和 docky。 主题下载 Mc-OS-themes, 使用 git 直接下载在 github 上的源码。 git clone git@github.com:paullinuxthemer/Mc-OS-themes.git 然后在 clone 下来的文件夹中选择你想要的 mac 版本样式，拷贝到 ~/.themes 文件夹下。例如 McOS-MJV-3.30 是 Mojava 版本的 OS X 的仿制主题。在 gnome tweak 中可以进行外观管理，应用程序 选择 McOS-MJV-3.30 即可。 图标下载 la-capitaine-icon-theme 图标源码, 可以直接 clone 到图标文件夹： mkdir ~/.iconscd ~/.iconsgit clone git@github.com:keeferrourke/la-capitaine-icon-theme.git 在 tweak 中进行外观管理，图标选择 la-capitaine-icon-theme 即可拥有 mac 的大图标。 dock要想改得像 mac 主题，最明显的特征是那个大 dock 栏。使用 docky 可以拥有这种感觉。 yay -S docky 安装完了之后，可以把 gnome 左侧的 dock 栏去掉了。在 tweak 设置中拓展下有个 dash to dock， 把这个拓展关掉就不显示左侧的 dock 栏了。 安装完之后的效果： manjaro-theme1.png 字体文泉系列字体： yay -S wqy-microhei-liteyay -S wqy-bitmapfont yay -S wqy-zenhei adobe 系列字体及其他： yay -S adobe-source-han-sans-cn-fonts yay -S adobe-source-han-serif-cn-fonts yay -S noto-fonts-cjk 快捷键打开设置&gt;设备&gt;Keyboard ，最下面的加号新增快捷方式 (注意是 Gnome 主题) Terminal: 命令 /usr/bin/gnome-terminal, 快捷键 Super + T synapse: 命令 synapse, 快捷键 Super + R 深度截图： 命令 deepin-screenshot, 快捷键 Ctrl + Alt + A 打开文件管理器： 命令 nautilus, 快捷键 Super + E ssr安装 electron-ssr 需要安装 python 和 shadowsocksr: yay -S python shadowsocksr 去 electron-ssr 的 github仓库 中下载 release 发布包。 其中 electron-ssr-0.2.4-x86_64.AppImage 可以用于各种 linux 环境直接执行。 chmod a+x electron-ssr-0.2.4-x86_64.AppImage./*.AppImage 安装之后运行，可能在任务栏没有图标，根据 FAQ 说明是因为环境中缺少libappindicator1 应用指示器。 查看到 Issue #180 和 Issue #176， 尝试安装sudo pacman -S libappindicator-sharp libappindicator-gtk3或者sudo pacman -S libappindicator-gtk2 远程连接远程桌面管理，支持VNC、SSH、RDP等，使用 Remmina，功能强大，配置简单。如果要使用 Remmina 进行 RDP 连接，需要安装 freerdp 。管理 FTP 文件服务器，可以使用 Filezilla. yay -S freerdp remmina teamviewerteamview 是我最常用的远程控制软件，安装 teamview： yay -S teamviewer 安装完了之后发现无法链接服务器，连本机ID都不显示了，查询了一些文档，在 Teamviewer-beta 13, “Not ready, please check connection” 这篇文章中找到解决方法。 sudo teamviewer --daemon enable或者systemctl enable teamviewerdsystemctl start teamviewerd 记得右键任务图标退出再重新打开，看能不能链接上服务器。 虚拟机 virtualbox具体安装参考 manjaro 的官方 wiki： VirtualBox 首先使用 uname -r 查看 manjaro 的内核版本，我的是 4.19.0-Manjaro，在后面选择 virtualbox 模块的时候选择 linux419-virtualbox-host-modules sudo pacman -S virtualbox 还可以安装 virtualbox-ext-oracle Oracle 拓展包 配置菜单或者启动器参考 manjaro 官方的 wiki： Desktop entries (简体中文))应用程序配置项，即 .desktop 文件是原信息资源和应用程序快捷图标的集合系统程序的配置项通常位于 /usr/share/applications 或 /usr/local/share/applications 目录，单用户安装的程序位于 ~/.local/share/applications 目录，优先使用用户的配置项。 cd ~/.local/share/applicationsvi idea.desktop[Desktop Entry]Type=ApplicationVersion=1.0Name=IntelliJ IDEAExec=/opt/ide/idea/bin/idea.shIcon=/opt/ide/idea/bin/idea.pngTerminal=falseCategories=Development;Languages;Java; Manjaro Gnome 在 ~/.config/autostart 目录下, 输入下列内容： Name[zh_CN]=Guake 终端Name=Guake TerminalComment=Use the command line in a Quake-like terminalTryExec=guakeExec=guakeIcon=guakeType=ApplicationCategories=GNOME;GTK;System;Utility;TerminalEmulator;StartupNotify=trueX-Desktop-File-Install-Version=0.22 或者在 Manjaro Gnome 中使用 tweaks 管理开机启动项，程序会创建以上内容。 修改 grub2 的等待时间无论你的电脑是否有 2个或更多的操作系统，只要安装了 LinuxMint/Ubuntu，就必然会安装grub2作为引导管理器。grub2 启动时，会在默认的启动项上停留数秒（默认 10秒），等待用户选择。我们可以把这个时间改的更短。如果是 LinuxMint/Ubuntu 单系统，可以直接改为0，即直接进入，无需等待。以管理员身份编辑 grub 配置文件，修改 GRUB_TIMEOUT 项后的数字。 sudo vi /etc/default/grub 个人安装记录yay -S fcitx-im fcitx-configtool fcitx-sogoupinyin fcitx-cloudpinyin fcitx-gtk2 yay -S git vim zsh oh-my-zsh-gityay -S electronic-wechat-git deepin.com.qq.office deepin.com.qq.im telegram-desktop deepin-screenshotyay -S python python-pip libappindicator-sharp libappindicator-gtk3 yay -S guake synapse albert docky copyq screenfetch bleachbit goldendict meld gitkrakenyay -S google-chrome firefox firefox-i18n-zh-cn thunderbird thunderbird-i18n-zh-cn man-pages-zh_cn visual-studio-code-bin netease-cloud-music smplayeryay -S wqy-microhei-lite wqy-bitmapfont wqy-zenhei adobe-source-han-sans-cn-fonts adobe-source-han-serif-cn-fonts noto-fonts-cjkyay -S jdk8 maven teamviewsudo archlinux-java statussudo archlinux-java set java-8-jdksudo teamviewer --daemon enable或者systemctl enable teamviewerdsystemctl start teamviewerdsudo vi ~/.xprofileexport GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=&quot;@im=fcitx&quot;cp /usr/share/oh-my-zsh/zshrc ~/.zshrc #ohmyzsh配置文件sudo chsh -s /bin/zsh #替换默认shellsudo pip install shadowsockscurl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bashsudo vi ~/.zshrcexport NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/bash_completion&quot; # This loads nvm bash_completionnvm install nodenvm use nodenpm config set registry https://registry.npm.taobao.orgnpm install -g nrmnrm testnrm use cnpmchmod a+x electron-ssr-0.2.4-x86_64.AppImage./*.AppImagemkdir ~/.themes ~/.icons ~/projectgit clone git@github.com:paullinuxthemer/Mc-OS-themes.git ~/projectcp -r ~/project/Mc-OS-themes/McOS-MJV-3.30 ~/.themes/git clone git@github.com:keeferrourke/la-capitaine-icon-theme.git ~/.icons 其他软件在包管理软件中搜索或者使用 pacman/yaourt/aurman 等命令行进行搜索下载。以下的软件有一些还没有试用过，在别人的文章中看到的，在此先记录一下。 Teamview：PC 远程控制/远程访问软件 Steam：游戏的分发平台 goldendict：linux 一款强大的字典 franz：通讯软件集合，包括 facebook、微信、google+ intellij-idea：java 开发工具 Intellij IDEA netease-cloud-music：网易云音乐 smplayer: 视频播放器 masterpdfeditor 对linux用户免费的PDF浏览及编辑器，支持实时预览； remarkable： 卓越且功能齐全的 Markdown 编辑器 uget： 媲美迅雷的下载工具； filezilla： 强大的FTP工具； deepin-screenshot： 深度截图工具； shutter： 强大的截图工具，gnome-web-photo配合使用； bleachbit： 快速释放磁盘空间并不知疲倦地守卫你的隐私。释放缓存，删除 cookie，清除互联网浏览历史，清理临时文件，删除日志，以及更多功能… thunderbird： Mozilla 旗下的邮件管理软件 redshift： 根据你的周边调整你屏幕的色温。当你夜晚在屏幕前工作时，它也许能帮助你减少对眼睛的伤害； wiznote 为知笔记； meld 文本比较； goldendict 词典软件； easystroke 鼠标手势； catfish 基于GTK+的非常快速，轻量级的文件搜索工具； peek 屏幕录像工具，小巧玲珑，可保存录像为gif动图和兼容于html5的webm视频； dbeaver 通用数据库客户端，支持多个平台及多种数据库，社区版是免费的； nethack 经典的命令行游戏，启动命令行nethack； gnome-mines 经典的扫雷游戏（gnome桌面自带，kde也有类似的kmines）； 2048-qt 经典的2048游戏； zaz 经典的泡泡射击游戏； sudokuki 基于Java的跨平台的数独游戏（https://sourceforge.net/projects/sudokuki/files/sudokuki/）； wesnoth 经典的韦诺之战，Linux上比较火的游戏，回合制策略游戏； 0ad 跨平台的“帝国时代”（http://sourceforge.net/projects/zero-ad/files/releases/locales/下载对应版本的汉化放到$HOME/.local/share/0ad/mods/public/）； Timeshift: 备份软件 总结Manjaro 是一个界面友好的 Linux 发行版，依赖于 Arch Linux 的 AUR 软件系统，拥有着众多的软件，及方便的使用操作。初次使用感觉还不错，众多的软件，甚至包括 Steam 都内置在了系统中。看Linux Kernel 的更新提示，Manjaro 的更新还是很频繁的，经常会有各种更新，更新的稳定性有待译后检查。在这里可以推荐给大家使用以下。","categories":[{"name":"系统","slug":"系统","permalink":"https://github.com/zzycreate/categories/系统/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/zzycreate/tags/Linux/"},{"name":"ArchLinux","slug":"ArchLinux","permalink":"https://github.com/zzycreate/tags/ArchLinux/"},{"name":"Manjaro","slug":"Manjaro","permalink":"https://github.com/zzycreate/tags/Manjaro/"}]},{"title":"个人npm命令记录","slug":"个人npm命令记录","date":"2018-10-23T13:47:53.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"2018/10/23/个人npm命令记录/","link":"","permalink":"https://github.com/zzycreate/2018/10/23/个人npm命令记录/","excerpt":"记录一些在使用 npm 时，常用的命令记录。使用任何工具最好的方式：npm 官网文档","text":"记录一些在使用 npm 时，常用的命令记录。使用任何工具最好的方式：npm 官网文档 npm 更新使用 npm -v 命令进行 npm 的版本查询。 更新 npm 到最新或者指定的版本： npm install npm@latest -gnpm install npm@6.3.0 -g 更新 npm 全局安装的指定包： npm update -g &lt;pkg...&gt; npm 设置环境变量使用 npm set 设置环境变量 $ npm set init-author-name &apos;Your name&apos;$ npm set init-author-email &apos;Your email&apos;$ npm set init-author-url &apos;http://yourdomain.com&apos;$ npm set init-license &apos;MIT&apos; 上面命令等于为npm init设置了默认值，以后执行npm init的时候，package.json的作者姓名、邮件、主页、许可证字段就会自动写入预设的值。这些信息会存放在用户主目录的 ~/.npmrc文件，使得用户不用每个项目都输入。如果某个项目有不同的设置，可以针对该项目运行npm config。 $ npm config set save-prefix ~ 上面的命令使得 npm install --save 和 npm install --save-dev 安装新模块时，允许的版本范围从克拉符号（^）改成波浪号（~），即从允许小版本升级，变成只允许补丁包的升级。 $ npm config set init.author.name $name$ npm config set init.author.email $email 上面命令指定使用npm init时，生成的package.json文件的字段默认值。 npm 信息查询npm info &lt;pkg&gt; &lt;field&gt;$ npm info underscore descriptionJavaScript&apos;s functional programming helper library.$ npm info underscore homepagehttp://underscorejs.org$ npm info underscore version1.5.2 使用 npm info 命令可以查看每个模块的具体信息。 $ npm search &lt;搜索词&gt; 查询 npm 仓库中包的信息。 npm 依赖结构$ npm list npm list 命令以树型结构列出当前项目安装的所有模块，以及它们依赖的模块。 $ npm list -global 加上 global 参数，会列出全局安装的模块。 $ npm list -global -depth 0 加 -depth 0 指定只展示全局一级依赖。","categories":[{"name":"收集","slug":"收集","permalink":"https://github.com/zzycreate/categories/收集/"}],"tags":[{"name":"个人收集","slug":"个人收集","permalink":"https://github.com/zzycreate/tags/个人收集/"},{"name":"NPM","slug":"NPM","permalink":"https://github.com/zzycreate/tags/NPM/"}]},{"title":"个人IDEA插件收藏","slug":"个人IDEA插件收藏","date":"2018-10-15T22:15:48.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"2018/10/15/个人IDEA插件收藏/","link":"","permalink":"https://github.com/zzycreate/2018/10/15/个人IDEA插件收藏/","excerpt":"IntelliJ IDEA 的插件众多，有一些插件能够提高开发人员的开发效率，本文记录一些个人使用的IDEA插件。","text":"IntelliJ IDEA 的插件众多，有一些插件能够提高开发人员的开发效率，本文记录一些个人使用的IDEA插件。 .ignore插件提供各种 .ignore 文件的模板。例如 .gitignore 有各种语言的模板，可以快速过滤一些工具或者语言产生的不需要提交 git 的各种文件。 Alibaba Java Coding Guidelines依照《阿里巴巴Java开发手册》进行项目代码分析，并可以根据插件进行代码优化。p3c的git地址：https://github.com/alibaba/p3c JRebel for IntelliJJRebel 热部署插件 Free Mybatis pluginFree Mybatis plugin 是 MyBatisCodeHelperPro 的免费简化版本，myabtis 插件基本需要的功能都有。 Rainbow BracketsRainbow Brackets 给各种括号提供彩色配色，可以更方便的识别括号范围。 Lombok PluginLombok Plugin 提供 lombok 的插件提供，可以省略 getter、setter、toString 等方法的书写，并提供一些常用模式的注入，例如 builder 方法、slf4j 等。 Maven HelperMaven Helper 插件增强 maven 的 pom 文件解析，可以快速解决 maven 依赖冲突，查找依赖层级结构。 CodeGlanceCodeGlance 提供代码右侧导航小地图。 AceJumpAceJump 提供键盘快速查找单词的方式，当你想将光标跳到某个位置的时候，使用快捷键 Ctrl + ; 根据提示可以快速定位到指定的位置 IdeaVimIdeaVim 给 IDEA 带来了 vim 的操作方式，适合于熟悉 vim 的开发人员。 Grep ConsoleGrep Console 给控制台提供各种级别日志的背景着色，并可以根据用户进行自定义设置。 String ManipulationString Manipulation 可以快速的将字符串转换为驼峰、小写、大写、下划线等各种格式，快捷键 Alt + M Git FlowGit Flow 提供 git flow 方式的 git 分支管理，并可以依照这种方式管理项目。 Markdown NavigationMarkdown Navigation 提供了 markdown 一种渲染方式，和 IDEA 默认提供的 markdown渲染插件有冲突，需要进行设置才能展示效果。 TranslationTranslation 提供了 google、有道、百度 三种翻译方式，可以快速翻译代码中的语言。 ReadHub使用 IDEA 进行新闻热点的阅读，适合用来摸鱼。","categories":[{"name":"收集","slug":"收集","permalink":"https://github.com/zzycreate/categories/收集/"}],"tags":[{"name":"个人收集","slug":"个人收集","permalink":"https://github.com/zzycreate/tags/个人收集/"},{"name":"IDE","slug":"IDE","permalink":"https://github.com/zzycreate/tags/IDE/"},{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://github.com/zzycreate/tags/IntelliJ-IDEA/"},{"name":"插件","slug":"插件","permalink":"https://github.com/zzycreate/tags/插件/"}]},{"title":"个人Linux使用命令记录","slug":"个人Linux使用命令记录","date":"2018-10-10T22:19:30.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"2018/10/10/个人Linux使用命令记录/","link":"","permalink":"https://github.com/zzycreate/2018/10/10/个人Linux使用命令记录/","excerpt":"linux 的命令非常的多，有一些有效但是不常用的命令，可能需要临时进行翻阅，记录部分有效命令以备查阅使用","text":"linux 的命令非常的多，有一些有效但是不常用的命令，可能需要临时进行翻阅，记录部分有效命令以备查阅使用 收藏网站 鳥哥的 Linux 私房菜 http://linux.vbird.org/ linux 命令手册 http://linux.51yip.com/ 命令压缩包相关tar 命令tar 参数： -A, --catenate, --concatenate 追加 tar 文件至归档* -c, --create 创建一个新归档 -d, --diff, --compare 找出归档和文件系统的差异 --delete 从归档(非磁带！)中删除 -r, --append 追加文件至归档结尾 -t, --list 列出归档内容 -u, --update 仅追加比归档中副本更新的文件* -x, --extract, --get 从归档中解出文件* -v, --verbose 详细地列出处理的文件* -f, --file=ARCHIVE 使用归档文件或 ARCHIVE 设备，命令后必须跟文件名* -C, --directory=DIR 改变至目录 DIR --exclude=PATTERN 排除以 PATTERN 指定的文件 -a, --auto-compress 使用归档后缀来决定压缩程序 -I, --use-compress-program=PROG 通过 PROG 过滤(必须是能接受 -d选项的程序)* -j, --bzip2 通过 bzip2 过滤归档* -z, --gzip, --gunzip, --ungzip 通过 gzip 过滤归档* -Z, --compress, --uncompress 通过 compress 过滤归档* -J, --xz filter the archive through xz 解压与解包各种类型的包解压： # *.tar 解包$ tar -xvf xx.tar [-C dir/]# *.zip 解压$ unzip xx.zip dir/# *.rar 解压$ rar x xx.rar# *.gz 解压$ gunzip xx.gz或$ gzip -d xx.gz# *.tar.gz 解压$ tar -xzvf xx.tar.gz [-C dir/]# *.bz2 解压$ bzip2 -d xx.bz2或$ bunzip2 xx.bz2# *.tar.bz2 解压$ tar -xjvf xx.tar.bz2 [-C dir/]# *.Z 解压$ uncompress xx.Z# *.tar.Z 解压$ tar -xZvf xx.tar.Z [-C dir/]# *.xz 解压$ xz -d xx.tar.xz# *.tar.xz 解压$ tar -xJvf xx.tar 压缩与打包各种类型的包压缩： # *.tar 打包$ tar -cvf xx.tar file dir/ ...# *.zip 压缩$ zip xx.zip file...# *.rar 压缩$ rar a xx.rar file...# *.gz 压缩$ gzip file# *.tar.gz 打包压缩$ tar -czvf xx.tar.gz file dir/ ...# *.bz2 压缩$ bzip2 -z file# *.tar.bz2 打包压缩$ tar -cjvf xx.tar.bz2 file dir/ ...# *.Z 压缩$ compress xx.tar.Z# *.tar.Z 打包压缩$ tar -cZvf xx.tar.Z file dir/ ...# *.xz 压缩$ xz -z xx.tar.xz# *.tar.xz 打包压缩$ tar -cJvf xx.tar file dir/ ... 磁盘空间df (Disk Free)df 是用于整个系统的空间使用查询。df命令使用的是 statfs 这个系统调用，直接读取分区的超级块信息获取分区使用情况。它的数据是基于分区元数据的，所以只能针对整个分区。由于df直接读取超级块，所以运行速度不受文件多少影响。 $ df [-ahikHTm] [目录/文件名]选项与参数：-a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；-k ：以 KBytes 的容量显示各文件系统；-m ：以 MBytes 的容量显示各文件系统；-h ：以人类较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；-H ：以 M=1000K 取代 M=1024K 的进位方式；-T ：连同该 partition 的 filesystem 名称 (例如 xfs) 也列出；-i ：不用磁盘容量，而以 inode 的数量来显示 常用命令： # 以容易阅读的方式查看所有磁盘的容量$ df -ah du (Disk Usage)du 是用于指定文件的空间使用查询。du 命令会对待统计文件逐个调用 fstat 这个系统调用，获取文件大小。它的数据是基于文件获取的，所以有很大的灵活性，不一定非要针对一个分区，可以跨越多个分区操作。如果针对的目录中文件很多，du速度就会很慢了。 $ du [-ahskm] 文件/目录名选项与参数：-a ：列出所有的文件及目录容量，因为预设仅统计目录底下的文件数量而已。-h ：以人类较容易阅读的容量格式 (G/M) 显示；-s ：列出总量而已，而不列出每个目录占用容量；-S ：不包括子目录下的总计，与 -s 有点差別。-k ：以 KBytes 列出容量显示；-m ：以 MBytes 列出容量显示； 常用命令： # 以容易阅读的方式查看当前目录所有文件的大小du -sh * 以容易阅读的方式查看当前目录所有文件的大小，并且只显示一层目录： du -sh --max-depth=1 * 有时候需要排序现实，简单的方式是使用 sort 命令协助排序，因此不能使用 -h 参数，-h 参数展示的单位会影响排序结果,另外再组合 head、tail 等命令只截取前后部分的数据，方便使用。 du -s * | sort -nr |head git 命令git rm 删除远端已提交文件git rm --cached &lt;file&gt; ssh-keygen 生成ssh密钥对ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; 删除 git 配置git config --unset user.name","categories":[{"name":"收集","slug":"收集","permalink":"https://github.com/zzycreate/categories/收集/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/zzycreate/tags/Linux/"},{"name":"个人收集","slug":"个人收集","permalink":"https://github.com/zzycreate/tags/个人收集/"}]},{"title":"Hexo博客添加评论系统","slug":"Hexo博客添加评论系统","date":"2018-10-03T12:24:25.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"2018/10/03/Hexo博客添加评论系统/","link":"","permalink":"https://github.com/zzycreate/2018/10/03/Hexo博客添加评论系统/","excerpt":"很多人写博客的目的是给自己做记录的，例如我，但是一个使用难免会有些寂寞，有时候会想要让跟多人看见自己的成果，这时候就需要可以互动评论的系统。现在的博客评论插件系统很多，尝试了一番，最终选择使用 gitalk 评论系统。","text":"很多人写博客的目的是给自己做记录的，例如我，但是一个使用难免会有些寂寞，有时候会想要让跟多人看见自己的成果，这时候就需要可以互动评论的系统。现在的博客评论插件系统很多，尝试了一番，最终选择使用 gitalk 评论系统。 评论系统选型在之前的 Hexo博客折腾记 中，选择了一系列可以方便免费开源部署的程序部署了博客，这次也不例外，需要选择免费开源容易部署的评论系统。 我部署的 Hexo 版本为 3.7.0, indigo 主题版本为 1.7.2 .这版本的 indigo 主题默认就集成有多种评论系统。这些系统有： disqus : disqus.com/ ———— 界面好看，支持 Facebook、twitter、Google+ 等账号登陆，但是 需要科学上网。 友言 : www.uyan.cc/ ———— 系统已经挂了 gitment : gitment ———— 基于 github issue 系统的评论系统， 已经很长时间没有维护了 valine : valine ———— 基于 Leancloud 的快速、简洁且高效的无后端评论系统 Hyper Comments : HyperComments ———— 已于2018.06.15起不再提供免费服务 由以上已经支持的集中评论系统来看，很多已经不能使用了。网上看了一下大多数的博客评论系统，以前使用 多说、网易云更贴 等广受好评的评论系统也都宣布停止服务。 现在做的还可以的评论系统： 畅言 : 畅言 ———— 搜狐出品，专业的社会化评论系统，需要备案，参考：知乎 - 搜狐做畅言评论系统的目的是什么？ valine : valine ———— valine 支持匿名评论 来必力 : ———— 来必力是一款以社交网站评论为基础, 帮助用户之间实现自由沟通的内容平台。无需注册, 支持各种社交账号。 gitalk : gitalk ———— Gitalk 是一个基于 GitHub Issue 和 Preact 开发的评论插件。 由于看到众多评论系统相继关闭和停止服务，我觉得评论系统需要有稳定的服务才能够持续为博客提供支持，最终我选择了基于 Github issues 的 gitalk 。毕竟一旦 github 都不能用了的话，当前基于 Github Pages 的博客也会无法使用 。 Gitalk 的使用gitalk 的准备工作阅读说明gitalk 官方中文说明 ： https://github.com/gitalk/gitalk/blob/master/readme-cn.md GitHub ApplicationGitHub Application 是 github 提供的应用 Oauth2 授权功能。可以用于外部应用使用 github 提供的账号授权系统。因为 gitalk 的评论使用的是 github issues ，评论必须使用 github 账号，所以用户如果需要使用 gitalk 进行评论，就必须使用自己的 github 账号给这个应用授权。 GitHub Application 的申请地址： Register a new OAuth applicationGitHub Application 的说明文档： Authorizing OAuth Apps页面中 Application name 为你的应用名，在用户授权页面展示用。页面中 Homepage URL 为主页URL。页面中 Application description 为应用描述。页面中 Authorization callback URL 为授权回调地址，这个最为关键，需要填写用户授权完成后回调的地址，一般来说就是你的博客地址 xxx.github.io 申请应用之后，就能获得应用的 clientID 和 clientSecret ，这两个东西需要配置到 gitalk 中，而且只会出现一次，请当时就记录下来。 indigo 主题集成 gitalkgitalk.ejs仿照 gitment 进行改造，在 themes/indigo/layout/_partial/plugins 目录下可以看见 gitment.ejs 文件。这个 ejs 文件是引入 gitment 用的。 类似的在 themes/indigo/layout/_partial/plugins 目录下创建一个名为 gitalk.ejs 的文件。文件类容如下 &lt;% if (theme.gitalk.enable)&#123; %&gt;&lt;section class=&quot;comments&quot; id=&quot;comments&quot;&gt; &lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt; &lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var gitalk = new Gitalk(&#123; clientID: &apos;&lt;%- theme.gitalk.client_id %&gt;&apos;, clientSecret: &apos;&lt;%- theme.gitalk.client_secret %&gt;&apos;, repo: &apos;&lt;%- theme.gitalk.repo %&gt;&apos;, owner: &apos;&lt;%- theme.gitalk.owner %&gt;&apos;, admin: &apos;&lt;%- theme.gitalk.admin %&gt;&apos;, id: location.pathname, // Ensure uniqueness and length less than 50 perPage: 50, distractionFreeMode: &apos;&lt;%= theme.gitalk.distractionFreeMode %&gt;&apos; &#125;) gitalk.render(&apos;gitalk-container&apos;) &lt;/script&gt;&lt;/section&gt;&lt;% &#125; %&gt; 参见 gitalk 的引用说明： Gitalk 安装引入 gitalk.css 样式文件、gitalk.min.js js 源码文件、script` 标签中书写 gitalk 的 js 应用代码。代码里面的 clientID 和 clientSecret 是上文中申请的应用里面的 id 和密钥。repo 是评论加载的仓库名，记住只是仓库名，不是 git 克隆的地址，可以直接使用 hexo 部署的 xxx.github.io 仓库，也可以另外新建一个仓库。owner 是评论仓库 repo 的持有者。admin 是评论的管理员，可以填多个（数组），管理员是 GitHub repository 的所有者和合作者 (对这个 repository 有写权限的用户)，可以初始化文章评论。id 是页面的唯一标识，一般来说一个文章的地址是唯一的，所以默认是 location.pathname 。不过 github issues 某次改版之后，这个值限制在50个字符内。其他非必填字段，参考：gitalk 设置 comment.ejs上文定义了 gitalk 插件的内容。要将插件引入进来，还需要修改 comment.ejs ，将 gitalk 引入进来。 参考 themes/indigo/_partial/post/comment.ejs 中其他部分，在其中添加一行代码： &lt;%- partial(&apos;../plugins/gitalk&apos;) %&gt; 这样就会将 gitalk.ejs 的代码引入进页面。 _config.yml在 indigo 主题的配置文件 themes/indigo/_config.yml 中添加上文 js 需要引用到的变量 # gitalk detail: https://github.com/gitalk/gitalkgitalk: enable: true client_id: xxx client_secret: xxxx repo: repo name # 仓库名 owner: repo owner # 仓库作者 admin: admins # 管理员 distractionFreeMode: false 集成中的问题gitalk 使用的 id 超限gitalk 使用的是 github issues ，issues 在某次更新之后，labels 的长度限制在 50 以内，因此使用 location.pathname 很容易就超过 50 字的限制。 参考 Gitalk Issues #102: 使用 md5 进行路径的加密，这样就能保证 id 在 50 字以内，并且是唯一的。 从 blueimp/JavaScript-MD5 中下载 md5.min.js . 将js放在 themes/source/js 目录下 gitalk.ejs 文件中引入 &lt;script src=&quot;/js/md5.min.js&quot;&gt;&lt;/script&gt; id 的配置改为 md5(location.pathname) 最终的 gitalk.ejs 配置如下： &lt;% if (theme.gitalk.enable)&#123; %&gt;&lt;section class=&quot;comments&quot; id=&quot;comments&quot;&gt; &lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt; &lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/js/md5.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var gitalk = new Gitalk(&#123; clientID: &apos;&lt;%- theme.gitalk.client_id %&gt;&apos;, clientSecret: &apos;&lt;%- theme.gitalk.client_secret %&gt;&apos;, repo: &apos;&lt;%- theme.gitalk.repo %&gt;&apos;, owner: &apos;&lt;%- theme.gitalk.owner %&gt;&apos;, admin: &apos;&lt;%- theme.gitalk.admin %&gt;&apos;, id: md5(location.pathname), perPage: 50, distractionFreeMode: &apos;&lt;%= theme.gitalk.distractionFreeMode %&gt;&apos; &#125;) gitalk.render(&apos;gitalk-container&apos;) &lt;/script&gt;&lt;/section&gt;&lt;% &#125; %&gt; 这样在 github issues 页面就可以看见一串 md5 的 label ，并且评论不会因为 50 字限制而出现问题 id 使用 pathname 而不要使用 href根据 Gitalk Issues #102 反馈，有些人使用微信浏览器时，url中会带有微信部分特征 url ，这会导致计算 md5 时出现异常。这是因为引入 gitalk 时使用的是 location.href ，因为 href 是整个 url，而 pathname 是 url 中请求映射的部分，不带域名或者 IP 端口部分的地址，这样会屏蔽掉微信等方式导致的 id 计算异常。 结束希望 gitalk 可以让我少折腾一点评论系统。如果频繁的改动评论系统，会丢失多少重要的数据，这些数据都是很宝贵的。","categories":[{"name":"教程","slug":"教程","permalink":"https://github.com/zzycreate/categories/教程/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://github.com/zzycreate/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://github.com/zzycreate/tags/博客/"},{"name":"教程","slug":"教程","permalink":"https://github.com/zzycreate/tags/教程/"},{"name":"评论","slug":"评论","permalink":"https://github.com/zzycreate/tags/评论/"},{"name":"gitalk","slug":"gitalk","permalink":"https://github.com/zzycreate/tags/gitalk/"}]},{"title":"Hexo博客折腾记","slug":"Hexo博客折腾记","date":"2018-10-02T17:38:31.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"2018/10/02/Hexo博客折腾记/","link":"","permalink":"https://github.com/zzycreate/2018/10/02/Hexo博客折腾记/","excerpt":"最近突然看到同事的博客，感慨于大佬多年来的各种记录。突然发现自己平时虽然会网上看很多东西，但都没什么整理。以前有段时间想着记录下平时的问题，还放在github上，建了个仓库，但过了一阵子又忘记了，而且用github仓库记录也不方便观看，因此又激起了折腾博客的想法，遂有了当前的这个博客。因为不知道会坚持多久，所以用了网上现在流行的 Hexo 和免费的 GitHub Pages 来搭建一个静态博客，仅以此文做配置博客的记录，希望也可以帮助到一些人。接下来就是喜闻乐见的博客教学环节。","text":"最近突然看到同事的博客，感慨于大佬多年来的各种记录。突然发现自己平时虽然会网上看很多东西，但都没什么整理。以前有段时间想着记录下平时的问题，还放在github上，建了个仓库，但过了一阵子又忘记了，而且用github仓库记录也不方便观看，因此又激起了折腾博客的想法，遂有了当前的这个博客。因为不知道会坚持多久，所以用了网上现在流行的 Hexo 和免费的 GitHub Pages 来搭建一个静态博客，仅以此文做配置博客的记录，希望也可以帮助到一些人。接下来就是喜闻乐见的博客教学环节。 博客选型因为不确定对博客会有多大的热度，优先选择可以免费部署、方便拓展、技术栈熟悉的博客类型，再者依托被微软收购的 GitHub 这一大平台应该一段时间内不用担心会关闭的危险。 常见的博客框架有 WordPress(基于php)、jekyll/jekyll(基于Ruby)、hexojs/hexo(基于Node.js)、getpelican/pelican(基于Python)、gohugoio/hugo(基于Golang)，可以看出各种动态语言在这方面都有现成的博客生成器，想了解更多博客类型：Static Site Generators 由于对其他语言不熟，对js还算是了解一点，最终选择 Hexo 。 其实使用哪个博客对写作来说没有太大的影响，现在的博客框架基本将大多数的功能都已经完成得差不多了，专注内容的同学其实使用默认配置就足够了，但是总会有很多强迫症程序员总会有些大胆的想法，要魔改出一个独一无二的博客，这大概就需要花费很多精力了。 安装准备Hexo 官方的文档有中文，很值得阅读一遍，内容也不算很多，照着文档过一遍就能安装部署完成。 Hexo官方网站：hexo.io Node.js 的安装由于 Hexo 是基于 Node.js 的静态博客生成框架，首先你的电脑需要安装 Node.js 的程序。 安装地址： nodejs.org , 选择LTS版本即可。或者根据 Hexo 官方提示 使用 nvm 进行 node 的安装。 安装完成之后在命令行中使用命令 node -v 即可看见 node 版本号，证明你的 nodejs 安装得没有问题。使用 npm -v 即可看见 npm 的版本号，npm 是 node 的包管理程序，在 npm 的仓库中托管着众多 node 开源项目。 Git 的安装Git 是一个分布式版本控制软件，GitHub 是基于 Git 进行版本控制的软件源码托管服务平台，GitHub 中有着众多的开源软件，在你博客的安装和改造过程中肯定能给你很多帮助。 hexo-cli命令hexo 的操作都是需要命令行来操作的，需要通过 node 和 npm 安装一个全局的 hexo 命令工具： hexo-cli 。 执行命令： npm install -g hexo-cli 如果执行过程中报错了，很可能是 npm 的下载源比较慢的缘故，参考文章 npm下载慢的解决方法 进行配置，再执行以上命令。如果还有其他问题，根据命令行的错误baidu或者google一下，一般都能找到解决方法。 安装完 hexo-cli 之后，可以使用 hexo -v 命令进行版本检查，使用 hexo v 可以获得更多相关的版本信息。 Hexo 的使用hexo-cli 命令行安装好了之后就可以进行 hexo 的使用。 博客源码的创建在想放置博客源文件的目录下，使用命令行执行命令： hexo init &lt;folder&gt;cd &lt;folder&gt;npm install hexo init 命令会在当前目录创建一个名称为 &lt;folder&gt; 的文件夹， cd 使命令行进入这个文件夹，执行 npm install 安装 hexo 的本地依赖。 执行完成之后，指定文件夹下会出现如下的目录结构： ├── /.deploy_git # 博客发布的文件目录├── /node_modules # node.js 的包管理目录├── /public # 博客编译后的文件目录├── /scaffolds # 默认模板目录├── /source # 文章资源目录| ├── /_drafts # 草稿文章目录| └── /_posts # 发布文章目录├── /themes # 主题文件夹| └── /landscape # 默认主题 landscape ├── _config.yml # 项目配置文件└── package.json # node.js 项目配置文件 scaffolds 目录是模板目录，使用 hexo 命令行创建的页面会根据参数的不同，使用这里面的模板生成页面文件 source 目录里面是存储博客的文章的，主要是 .md 后缀的 markdown 文件 themes 目录里面是放置 hexo 主题的源码的，主题使得 hexo 的生态更加丰富多样 _config.yml 是 hexo 的项目配置文件，主要是站点的基本信息和配置，hexo 的配置详细请参见： Hexo 配置 以上四个目录或者文件是 hexo 的主要内容部分。 Hexo 的命令Hexo 的使用都是用命令行的方式，常用的基本就几个命令。详细的命令参见： Hexo 指令 inithexo init [folder] init 用于新建网站内容，一般就只有初始化的时候使用一次 newhexo new [layout] &lt;title&gt; new 用于新建一篇文章，可以不填 layout ，默认为 post ，可以在 _config.yml 中进行配置。如果标题包含空格的话，请使用引号括起来。 新建了一片文章之后，会在对应的 _drafts、_post、{pageName}等目录下创建对应的 markdown 文件。这些 markdown 文件就是站点的主要内容。 generatehexo generate或者 hexo g generate 命令用于将站点源文件生成可以发布的文件，源文件在 source 文件夹中，发布文件在 public 文件夹中。生成的文件是根据 theme 主题和源文件生成的。 使用 -d 参数在文件生成后直接部署，使用 -w 参数监控文件变动进行发布文件生成。 cleanhexo clean clean 命令用于清除生成的站点文件，和 generator 刚好相反，执行完 clean 之后 public 文件夹会被清楚 serverhexo server server 命令在本地生成启动一个服务，用于预览生成的站点，默认访问地址为 http://localhost:4000/ deployhexo deploy deploy 命令用于发布站点到指定的地址，发布配置在 _config.yml 中可以进行配置，也可以同时发布到多个地址。 其他命令上述几个命令是最常使用的几个命令，其他命令参考官方教程：Hexo 指令 Hexo 主题折腾Hexo 之所以被很多人使用，一个原因是这个框架很简洁，需要掌握的东西不多，上述几个命令基本就足够使用；另一方面是 Hexo 有足够多的成熟主题和插件供大家使用。 Hexo 官方主题页：Hexo ThemesHexo 官方插件页：Hexo Plugins 官方提供的插件足够多，markdown、图片懒加载、表情、图标等等各种各样的功能都有，自己也可以编写插件进行功能的补全，插件具体的我就没有怎么研究过，这部分暂不讲解。 主题方面，我尝试了一些，GitHub 按照 star 排名来看，iissnan/hexo-theme-next 新版NexT、litten/hexo-theme-yilia、viosey/hexo-theme-material、yscoder/hexo-theme-indigo等主题应该是使用人群最多的。 我才刚折腾几天，暂时选择的是 hexo-theme-indigo，以后可能也会尝试使用其他主题 。 安装 indigo 主题根据 Hexo indigo 主题文档 进行安装。 官方推荐是使用 git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo 直接将主题项目 clone 到 themes/indigo 目录下，这样可以根据indigo的修改进行更新。 我是直接 Download ZIP 包，然后将 zip 包解压到themes目录下，这样就没有 git 的信息，我就可以直接将这个目录下的内容也和我整个项目一起提交到 git 远程仓库中。 下载完了之后，在 _config.yml 中进行修改，将 themes 的值设置为 indigo 即可。 indigo 的配置indigo 的目录结构如下： indigo├── /languages # 国际化目录├── /layout # 布局 ejs 文件| └── /_partial # 布局组件 ejs 文件| ├── /plugin # 布局插件组件 ejs 文件| └── /post # 布局页面组件 ejs 文件├── /scriptes # 脚本├── /source # 文章资源目录| ├── /css # css资源| ├── /img # 图片资源| └── /js # js资源└── _config.yml # indigo 主题配置文件 如果需要修改布局中的一些东西，则去 layout 中找到相应的组件，例如右侧的目录 toc 的组件在 layout/_partial/post/toc.ejs 文件中。如果需要修改主题的静态资源，则去 source 中找到相应的资源文件，进行修改，例如： 微信二维码是 source/img/wechat.jpg 文件。 一些主题的数据是提供了参数进行修改的，详细参数设置：indigo 参数配置 结束博客主题的折腾永无止境，主题也仅仅是给世人看的一副好看的匹狼，内容才是博客的灵魂，你想要记录什么样的内容给他人看到才是最重要的。","categories":[{"name":"教程","slug":"教程","permalink":"https://github.com/zzycreate/categories/教程/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://github.com/zzycreate/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://github.com/zzycreate/tags/博客/"},{"name":"GitHub Pages","slug":"GitHub-Pages","permalink":"https://github.com/zzycreate/tags/GitHub-Pages/"},{"name":"教程","slug":"教程","permalink":"https://github.com/zzycreate/tags/教程/"}]},{"title":"注解@Autowired和@Resource的区别","slug":"注解-Autowired和-Resource的区别","date":"2018-09-28T23:52:40.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"2018/09/28/注解-Autowired和-Resource的区别/","link":"","permalink":"https://github.com/zzycreate/2018/09/28/注解-Autowired和-Resource的区别/","excerpt":"在spring项目中，对bean进行注入通常会看见使用@Autowired和@Resource两种注解的注入方式，虽然两者的功能是一致的，但是在使用上有一些区别。","text":"在spring项目中，对bean进行注入通常会看见使用@Autowired和@Resource两种注解的注入方式，虽然两者的功能是一致的，但是在使用上有一些区别。 注解 @Resource注解 @Resource 是jdk1.6版本开始提供的注解，默认是使用byName的方式搜索bean，名称可以通过name属性进行指定。 注解 @Resource 注意事项： 如果注解指定了name，则根据name的值搜索bean进行装配。 如果没有指定name属性，当注解写在字段上时，默认取字段名，并按照名称查找，如果注解写在setter方法上默认取属性名进行装配。 当找不到与名称匹配的bean时才按照类型进行装配。 注意：name属性一旦指定，就只会按照名称进行装配。 注解 @Autowired注解@Autowired是spring2.5版本开始提供的注解，默认是使用byType的方式(根据Bean的class类型)搜索bean。 注解 @Autowired 注意事项： 默认是使用 byType 的方式(根据 Bean 的 class 类型)搜索bean, 如果查询结果刚好为一个，就将该 bean 装配给 @Autowired 指定的数据 如果搜索到多个 bean ，再使用 byName 的方式(根据 bean 实例上申明的名称)搜索，需要配合 @Qualifier 注解使用，名称写在 @Qualifier 注解上 如果查询的结果为空，那么会抛出异常。 @Autowired 默认情况下要求依赖对象必须存在，如果要允许 null 值，可以设置它的 required 属性为 false spring 注入 @Autowired 的时机问题 如果在成员属性或者 setter 方法上添加 @Autowired 注解注入，则该属性的值是在构造器之后才会注入，如果在构造器中就要使用这个属性，则会报空指针的异常 spring4 提供了在构造器上添加 @Autowired 注解的方法，spring 会向构造器中的入参注入 bean 实例，之后才会执行构造器内部的代码 spring 官方推荐 spring4 及以后版本使用构造器注入 bean ， IDEA 也对此提供了 Warning 级别的提示，并可以快速根据提示将注入改造为构造器注入的方式 spring的单元测试类中一般不使用构造器 @Autowired 注入，因为单元测试需要有无参构造器；如果要使用有参构造器，则需要在类上添加 @RunWith(Parameterized.class) 注解，并且增加带 @Parameters 注解的方法，Parameters 方法的方法签名必须是 public static Collection，方法不能有参数，并且 collection 元素必须是相同长度的数组，因此 spring 单元测试类一般不使用构造器注入的方式 总结如果是要使用spring的自动装配功能，一般情况下使用 @Resource 和 @Autowired 没有区别。@Autowired 提供的注入方式会更多一些，另外就是默认查找 bean 的方式有区别，但两者均会通过名称或者类型进行判定，因此也没有太大区别。@Autowired 在没有配置 requred = false 时，是强制检查是否有注入对象，会对程序运行起到有效的检查作用。","categories":[{"name":"编码","slug":"编码","permalink":"https://github.com/zzycreate/categories/编码/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/zzycreate/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://github.com/zzycreate/tags/spring/"}]},{"title":"修改git已提交的commit作者和邮箱","slug":"修改git已提交的commit作者和邮箱","date":"2018-09-27T16:44:59.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"2018/09/27/修改git已提交的commit作者和邮箱/","link":"","permalink":"https://github.com/zzycreate/2018/09/27/修改git已提交的commit作者和邮箱/","excerpt":"当需要在一台电脑上操作不同的git仓库时，很可能会出现不同仓库，需要不同的作者身份进行提交。例如：在公司使用域账号进行内网gitlab仓库的修改，而在github上又想使用网络的名称与邮箱，如果不注意提交人的信息，很可能就会导致身份错乱，暴露了一些信息。","text":"当需要在一台电脑上操作不同的git仓库时，很可能会出现不同仓库，需要不同的作者身份进行提交。例如：在公司使用域账号进行内网gitlab仓库的修改，而在github上又想使用网络的名称与邮箱，如果不注意提交人的信息，很可能就会导致身份错乱，暴露了一些信息。本文参考：git修改提交作者和邮箱 良好的git操作习惯如果有需要切换身份的要求，则必然需要养成切换代码库或克隆仓库时检查用户信息的习惯。 主动配置git的 user.name 和 user.email: // 设置全局git config --global user.name &quot;Author Name&quot;git config --global user.email &quot;Author Email&quot; // 或者设置本地项目库配置git config user.name &quot;Author Name&quot;git config user.email &quot;Author Email&quot; 修改历史代码用户信息有时候由于疏忽，还是会有代码已经提交才反应过来需要修改用户信息的情况。 最近一次commit的修改如果只需要最近一次提交，那么很简单直接使用 git commit --amend 就可以搞定 git commit --amend --author=&quot;NewAuthor &lt;NewEmail@address.com&gt;&quot; 多个commit的修改如果是多个修改，那么就需要使用到 git filter-branch 这个工具来做批量修改为了方便使用，封装了一个简单的shell脚本，直接修改 [XXX] 中的变量为对应的值即可 #!/bin/sh git filter-branch --env-filter &apos; an=&quot;$GIT_AUTHOR_NAME&quot;am=&quot;$GIT_AUTHOR_EMAIL&quot;cn=&quot;$GIT_COMMITTER_NAME&quot;cm=&quot;$GIT_COMMITTER_EMAIL&quot; if [ &quot;$GIT_COMMITTER_EMAIL&quot; = &quot;[Your Old Email]&quot; ]then cn=&quot;[Your New Author Name]&quot; cm=&quot;[Your New Email]&quot;fiif [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;[Your Old Email]&quot; ]then an=&quot;[Your New Author Name]&quot; am=&quot;[Your New Email]&quot;fi export GIT_AUTHOR_NAME=&quot;$an&quot;export GIT_AUTHOR_EMAIL=&quot;$am&quot;export GIT_COMMITTER_NAME=&quot;$cn&quot;export GIT_COMMITTER_EMAIL=&quot;$cm&quot;&apos; 注意修改的commit会导致git树与原来不同，如果之前的commit已经提交，则只能强制推送覆盖远端；如果有其他人已经拉取过之前的旧commit，则在你强制推送之后，别人再进行拉取会产生大量冲突的代码，因此修改需要谨慎。 参考 git修改提交作者和邮箱","categories":[{"name":"工具","slug":"工具","permalink":"https://github.com/zzycreate/categories/工具/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://github.com/zzycreate/tags/tools/"},{"name":"git","slug":"git","permalink":"https://github.com/zzycreate/tags/git/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-09-26T16:44:59.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"2018/09/26/hello-world/","link":"","permalink":"https://github.com/zzycreate/2018/09/26/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment 如何在文章中使用图标先到 fontawesome 找到你需要的图标名，比如：book，按以下格式使用： &lt;i class=&quot;icon icon-book&quot;&gt;&lt;/i&gt; 图标样式前缀均为 icon，此外还有 5 个图标大小调节类和 1 个间距类。 &lt;!-- 1.3倍大小 --&gt;&lt;i class=&quot;icon icon-book icon-lg&quot;&gt;&lt;/i&gt;&lt;!-- 2倍大小 --&gt;&lt;i class=&quot;icon icon-book icon-2x&quot;&gt;&lt;/i&gt;&lt;!-- 3倍大小 --&gt;&lt;i class=&quot;icon icon-book icon-3x&quot;&gt;&lt;/i&gt;&lt;!-- 4倍大小 --&gt;&lt;i class=&quot;icon icon-book icon-4x&quot;&gt;&lt;/i&gt;&lt;!-- 5倍大小 --&gt;&lt;i class=&quot;icon icon-book icon-5x&quot;&gt;&lt;/i&gt;&lt;!-- 5px右边距 --&gt;&lt;i class=&quot;icon icon-book icon-pr&quot;&gt;&lt;/i&gt;&lt;!-- 5px左边距 --&gt;&lt;i class=&quot;icon icon-book icon-pl&quot;&gt;&lt;/i&gt;","categories":[{"name":"测试","slug":"测试","permalink":"https://github.com/zzycreate/categories/测试/"}],"tags":[{"name":"test","slug":"test","permalink":"https://github.com/zzycreate/tags/test/"}]},{"title":"SpringBoot属性配置","slug":"SpringBoot属性配置","date":"2017-08-16T00:00:26.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"2017/08/16/SpringBoot属性配置/","link":"","permalink":"https://github.com/zzycreate/2017/08/16/SpringBoot属性配置/","excerpt":"Spring Boot 是约定大于配置的 Spring 版本，但是这并不是说 Spring Boot 就没有配置，Spring Boot可以使用多种方式进行配置的设置。以下介绍一番 SpringBoot 各种类型的属性配置。","text":"Spring Boot 是约定大于配置的 Spring 版本，但是这并不是说 Spring Boot 就没有配置，Spring Boot可以使用多种方式进行配置的设置。以下介绍一番 SpringBoot 各种类型的属性配置。 SpringBoot 属性配置优先级 命令行参数 来自 java:comp/env 的JNDI属性 Java系统属性(System.getProperties()) 操作系统环境变量 RandomValuePropertySource 配置的 random.* 属性 jar 包外部的 application-{profile}.properties 或 application.yml (带 spring.profile)配置文件 jar 包内部的 application-{profile}.properties 或 application.yml (带 spring.profile)配置文件 jar 包外部的 application.properties 或 application.yml (不带 spring.profile)配置文件 jar 包内部的 application.properties 或 application.yml (不带 spring.profile)配置文件 @Configuration 注解类上的 @PropertySource 通过 SpringApplication.setDefaultProperties 指定的默认属性 SpringBoot 属性配置命令行参数设置通过 Java -jar app.jar --name=&quot;Spring&quot; --server.port=9090 方式来传递参数。 其中参数用 --xxx=xxx 的形式传递。常见的Spring Boot默认配置参见 http://docs.spring.io/spring-boot/docs/1.2.3.RELEASE/reference/html/common-application-properties.html。 命令行参数写在 app.jar 后面。如果要禁用命令行配置，可以通过 SpringApplication.setAddCommandLineProperties(false) 让命令行设置无效。 Java 系统属性java -Dname=”isea533” -jar app.jar –name=”Spring!” 系统属性配置方法与命令行参数设置类似，可以配置的属性也是一样的，只是优先级方式不同。 操作系统环境变量和配置 JAVA_HOME 是一样的，只是例如 server.port 这种参数，无法支持，可以使用 SERVER_PORT 来配置。 RandomValuePropertySource系统中用到随机数的地方，可以使用这种方式。 my.secret=$&#123;random.value&#125;my.number=$&#123;random.int&#125;my.bignumber=$&#123;random.long&#125;my.number.less.than.ten=$&#123;random.int(10)&#125;my.number.in.range=$&#123;random.int[1024,65536]&#125; random.int*支持 value 和 ,max 参数,当提供max参数的时候，value就是最小值。 应用配置文件 (.properties或.yml).properties配置文件： name=Isea533server.port=8080 .yml配置文件： name: Isea533server: port: 8080 注意： 使用 .yml 时，属性值和冒号中间必须要有空格。 spring会从classpath下的 /config 目录或者classpath的根目录寻找 application.properties 或 application.yml。/config 优先于 classpath根目录。 @PropertySource@PropertySource 这个注解可以指定具体的属性配置文件，优先级比较低。 SpringApplication.setDefaultPropertiesSpringApplication application = new SpringApplication(Application.class);Map&lt;String, Object&gt; defaultMap = new HashMap&lt;String, Object&gt;();defaultMap.put(&quot;name&quot;, &quot;Isea-Blog&quot;);//还可以是Properties对象application.setDefaultProperties(defaultMap);application.run(args); 使用 SpringApplication.setDefaultProperties 的方式，可以设置默认属性值。 SpringBoot 属性的使用属性使用的方式@Value(“${xxx}”)使用 @Value 注解可以直接将属性值注入进来 @ConfigurationPropertiesmy.name=Isea533my.port=8080my.servers[0]=dev.bar.commy.servers[1]=foo.bar.com 以上的参数，使用的时候可以 @ConfigurationProperties(prefix=&quot;my&quot;)public class Config &#123; private String name; private Integer port; private List&lt;String&gt; servers = new ArrayList&lt;String&gt;(); public String geName()&#123; return this.name; &#125; public Integer gePort()&#123; return this.port; &#125; public List&lt;String&gt; getServers() &#123; return this.servers; &#125;&#125; @ConfigurationProperties 会将 prefix=&quot;my&quot;的属性注入进来。并且会自动转型到类的属性值上，对象属性需要先初始化。 Spring Boot还支持嵌套属性注入。 name=isea533jdbc.username=rootjdbc.password=root 对应的配置类： @ConfigurationPropertiespublic class Config &#123; private String name; private Jdbc jdbc; class Jdbc &#123; private String username; private String password; //getter... &#125; public Integer gePort()&#123; return this.port; &#125; public Jdbc getJdbc() &#123; return this.jdbc; &#125;&#125; jdbc开头的属性都会注入到Jdbc对象中。Spring Boot通过getter方法获得属性值。 @Bean上使用@ConfigurationProperties@ConfigurationProperties(prefix = &quot;foo&quot;)@Beanpublic FooComponent fooComponent() &#123; &#125; 在属性上同时使用 @ConfigurationProperties 和 @Bean 注解，可以将foo开头的属性按照名字匹配注入到FooComponent中去。 属性占位符在配置文件中可以引用前面配置过的属性，只要优先级在配置文件之前的都可以使用。 通过 ${xxx.xxx:默认名称} 方式还可以设置默认值，当找不到引用的属性时，会使用默认的属性。 由于 ${}的方式会被maven处理。如果pom继承的 spring-boot-starter-parent，Spring Boot会将 maven-resources-plugins 默认的 ${}方式改为 @ @ 的方式 通过属性占位符缩短命令参数web默认端口使用 –server.port=9090 那么在配置上可以写 server.port=$&#123;port:8080&#125; 在不提供 –port=9090 的时候，使用默认值 8080。 属性名匹配规则@Component@ConfigurationProperties(prefix=&quot;person&quot;)public class ConnectionSettings &#123; private String firstName;&#125; 以上配置对象可以使用的属性名如下： person.firstName,标准的驼峰式命名 person.first-name,虚线（ - ）分割方式，推荐在 .properties 和 .yml 配置文件中使用 PERSON_FIRST_NAME,大写下划线形式，建议在系统环境变量中使用。 属性验证可以使用 JSR-303 注解进行验证 @Component@ConfigurationProperties(prefix=&quot;connection&quot;)public class ConnectionSettings &#123; @NotNull private InetAddress remoteAddress; // ... getters and setters&#125;","categories":[{"name":"编码","slug":"编码","permalink":"https://github.com/zzycreate/categories/编码/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/zzycreate/tags/java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://github.com/zzycreate/tags/SpringBoot/"},{"name":"spring","slug":"spring","permalink":"https://github.com/zzycreate/tags/spring/"}]},{"title":"linux下部署多个tomcat","slug":"linux下部署多个tomcat","date":"2017-06-18T23:25:59.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"2017/06/18/linux下部署多个tomcat/","link":"","permalink":"https://github.com/zzycreate/2017/06/18/linux下部署多个tomcat/","excerpt":"部署javaweb程序最常见的就是使用tomcat，而tomcat默认使用8080端口，如果要部署多个tomcat，必然需要在配置上进行修改，本文记录linux下多tomcat部署的步骤，用于参考。","text":"部署javaweb程序最常见的就是使用tomcat，而tomcat默认使用8080端口，如果要部署多个tomcat，必然需要在配置上进行修改，本文记录linux下多tomcat部署的步骤，用于参考。 环境 Centos 6.5 tomcat-7.0.79 需要解决的问题 不同的tomcat启动和关闭监听不同的端口 不同的tomcat的启动文件startup.sh 中要指定各自的CATALINA_HOME和CATALINA_BASE这两个环境变量。 解决步骤 修改/etc目录下的profile文件，添加一组java环境变量，和两组CATALINA环境变量；修改后的profile文件示例如下： JAVA_HOME=/usr/java/jdkCLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib:$JAVA_HOME/binexport JAVA_HOME CLASSPATHCATALINA_BASE=/home/app/tomcat1CATALINA_HOME=/home/app/tomcat1export CATALINA_BASE CATALINA_HOMECATALINA_2_BASE=/home/app/tomcat2CATALINA_2_HOME=/home/app/tomcat2export CATALINA_2_BASE CATALINA_2_HOMETOMCAT_HOME=/home/app/tomcat1export TOMCAT_HOMETOMCAT_2_HOME=/home/app/tomcat2export TOMCAT_2_HOME 修改完毕后，source /etc/profile。可能是因为修改了profile文件的缘故？ 第一个安装在/home/app/tomcat1处的tomcat，保持解压后的原状不用修改。修改第二个安装在/home/app/tomcat2处的tomcat。需要修改两个地方： 3.1. 修改server.xml配置和第一个不同的启动、关闭监听端口。修改后示例如下： &lt;Server port=&quot;9085&quot; shutdown=&quot;SHUTDOWN&quot;&gt; 端口：8085-&gt;9085&lt;!-- Define a non-SSL HTTP/1.1 Connector on port 8080 --&gt; &lt;Connector port=&quot;9080&quot; maxHttpHeaderSize=&quot;8192&quot; maxThreads=&quot;150&quot; minSpareThreads=&quot;25&quot; maxSpareThreads=&quot;75&quot; enableLookups=&quot;false&quot; redirectPort=&quot;8443&quot; acceptCount=&quot;100&quot; connectionTimeout=&quot;20000&quot; disableUploadTimeout=&quot;true&quot; /&gt;端口：8080-&gt;9080 3.2. 修改bin下的startup.sh和shutdown.sh。修改后的示例如下：（同样的修改） export JAVA_HOME=/usr/jdkexport PATH=$PATH:$JAVA_HOME/binexport CLASSPATH=$JAVA_HOME/libexport CATALINA_HOME=$CATALINA_2_HOME `利用profile中第二组设置export CATALINA_BASE=$CATALINA_2_BASE `利用profile中第二组设置 在tomcat7.0中可以不修改startup.sh和shutdown.sh，只修改catalina.sh即可 CATALINA_HOME=$CATALINA_6_HOMECATALINA_BASE=$CATALINA_6_BASEexport CATALINA_HOMEexport CATALINA_BASE 分别进入两个tomcat的bin目录，启动tomcat–./startup.sh 然后访问http://localhost:8080 和 http://localhost:9080 都可以看到熟悉的tomcat欢迎界面。 如果想启动多个可以依此法类推…… 参考材料： http://blog.csdn.net/loadrunn/article/details/6579639","categories":[{"name":"系统","slug":"系统","permalink":"https://github.com/zzycreate/categories/系统/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/zzycreate/tags/Linux/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://github.com/zzycreate/tags/Tomcat/"}]},{"title":"Windows下查找端口占用并关闭进程","slug":"Windows下查找端口占用并关闭进程","date":"2017-05-18T23:20:14.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"2017/05/18/Windows下查找端口占用并关闭进程/","link":"","permalink":"https://github.com/zzycreate/2017/05/18/Windows下查找端口占用并关闭进程/","excerpt":"windows启动某个应用时，可能会出现由于端口被其他应用或者之前没有关闭的应用占用了而无法启动的情况，这时候需要关闭占用这个端口的进程。","text":"windows启动某个应用时，可能会出现由于端口被其他应用或者之前没有关闭的应用占用了而无法启动的情况，这时候需要关闭占用这个端口的进程。 Windows查看端口使用命令 netstat -ano 查看所有端口，使用 netstat -ano|findstr 8000 查看指定的8000端口。 查询出来的列表中，最后一列的数字为程序pid。 查询pid对应的进程使用命令 tasklist|findstr 2016 , 其中2016为上一命令查询出来的pid值，列出来的结果中第一列的名称为该pid代表的程序名。 关闭程序进程使用命令 taskkill /f /t /im 程序名 其中程序名为上一命令查询出来的第一列值程序名。 依次执行以上三命令，可以关闭占用指定端口的程序。","categories":[{"name":"系统","slug":"系统","permalink":"https://github.com/zzycreate/categories/系统/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://github.com/zzycreate/tags/windows/"}]},{"title":"script标签中的defer和async属性","slug":"script标签中的defer和async属性","date":"2017-04-30T02:34:09.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"2017/04/30/script标签中的defer和async属性/","link":"","permalink":"https://github.com/zzycreate/2017/04/30/script标签中的defer和async属性/","excerpt":"我们常用的script标签，有两个和性能、js文件下载执行相关的属性：defer和async","text":"我们常用的script标签，有两个和性能、js文件下载执行相关的属性：defer和async defer的含义【摘自https://developer.mozilla.org/En/HTML/Element/Script】 This Boolean attribute is set to indicate to a browser that the script is meant to be executed after the document has been parsed. async的含义【摘自https://developer.mozilla.org/En/HTML/Element/Script】 Set this Boolean attribute to indicate that the browser should, if possible, execute the script asynchronously. Defer如果一个script加了defer属性，即使放在head里面，它也会在html页面解析完毕之后再去执行，也就是类似于把这个script放在了页面底部。 对于defer，我们可以认为是将外链的js放在了页面底部。js的加载不会阻塞页面的渲染和资源的加载。不过defer会按照原本的js的顺序执行，所以如果前后有依赖关系的js可以放心使用。 Async对于async，这个是html5中新增的属性，它的作用是能够异步的加载和执行脚本，不因为加载脚本而阻塞页面的加载。一旦加载到就会立刻执行。 async属性和defer一样，会等待的资源不会阻塞其余资源的加载，也不会影响页面的加载。但是有一点需要注意下，在有async的情况下，js一旦下载好了就会执行，所以很有可能不是按照原本的顺序来执行的。如果js前后有依赖性，用async，就很有可能出错。 总结相同点： 加载文件时不阻塞页面渲染 对于inline的script无效 使用这两个属性的脚本中不能调用document.write方法 有脚本的onload的事件回调 区别点： html的版本html4.0中定义了defer；html5.0中定义了async 浏览器 Feature Chrome Firefox (Gecko) Internet Explorer Opera Safari Basic support 1.0 1.0(1.7 or earlier) (Supported) (Supported) (Supported) async attribute (Supported) 3.6 (1.9.2) 10 — (Supported) defer attribute (Supported) 3.5 (1.9.1) 4 — (Supported) 执行时刻: 每一个async属性的脚本都在它下载结束之后立刻执行，同时会在window的load事件之前执行。所以就有可能出现脚本执行顺序被打乱的情况；每一个defer属性的脚本都是在页面解析完毕之后，按照原本的顺序执行，同时会在document的DOMContentLoaded之前执行。 简单的来说，使用这两个属性会有三种可能的情况 如果async为true，那么脚本在下载完成后异步执行。 如果async为false，defer为true，那么脚本会在页面解析完毕之后执行。 如果async和defer都为false，那么脚本会在页面解析中，停止页面解析，立刻下载并且执行， 参考文章： http://ued.ctrip.com/blog/script-defer-and-async.html#","categories":[{"name":"编码","slug":"编码","permalink":"https://github.com/zzycreate/categories/编码/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/zzycreate/tags/javascript/"},{"name":"defer","slug":"defer","permalink":"https://github.com/zzycreate/tags/defer/"},{"name":"async","slug":"async","permalink":"https://github.com/zzycreate/tags/async/"}]},{"title":"shell命令中替换指令的区别","slug":"shell命令中替换指令的区别","date":"2017-04-14T22:46:14.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"2017/04/14/shell命令中替换指令的区别/","link":"","permalink":"https://github.com/zzycreate/2017/04/14/shell命令中替换指令的区别/","excerpt":"shell中$(())与${}还有${}的区别，shell中这几个命令都有替换的含义，使用起来有一些区别。","text":"shell中$(())与${}还有${}的区别，shell中这几个命令都有替换的含义，使用起来有一些区别。 $() 与 ` `(反引号)在bash shell中，$()与` `都是用来作为命令替换使用的。 两个命令都是完成括号或者反引号中的命令语句，然后将其结果替换出来，再用这个结果重组出一个新的命令。 $ echo the last sunday is $(date -d &quot;last sunday&quot; +%Y-%m-%d) 这样先执行 date -d &quot;last sunday&quot; +%Y-%m-%d 将算出来的上个星期天换算出来，再作为变量使用。 使用 $() 的理由 由于 ` ` (反引号)与 &#39; &#39; (单引号)很容易搞混，一些字体里面看起来都是类似的。 在多层次的复合替换中， ` ` 还需要使用 \\ 进行跳脱处理，而$()则比较直观。 $() 的不足` `基本上可以用在全部的unix shell中，移植为shell script比较容易，而$()则不见得能够正常使用。 ${} 与 $()${} 用来作为变量替换，与 $() 的命令替换是不同的。 一般情况下，$var 和 ${} 没有什么不同，但是 ${} 能够比较准确的界定变量名称的范围。 ${}还可以在变量名后面加上 #、##、%、%%、/、// 等替换出指定的变量结果。 以 path：/dir1/dir2/dir3/my.file.txt 为例： # 是去掉左边(在键盘上 # 在 $ 之左边) % 是去掉右边(在键盘上 % 在 $ 之右边) 单一符号是最小匹配﹔两个符号是最大匹配。 ${file:0:5}：提取最左边的 5 个字节：/dir1 ${file:5:5}：提取第 5 个字节右边的连续 5 个字节：/dir2 我们也可以对变量值里的字符串作替换： ${file/dir/path}：将第一个 dir 替换为 path：/path1/dir2/dir3/my.file.txt ${file//dir/path}：将全部 dir 替换为 path：/path1/path2/path3/my.file.txt 利用 ${ } 还可针对不同的变量状态赋值(没设定、空值、非空值)： ${file-my.file.txt}：假如 $file 没有设定，则使用 my.file.txt 作传回值。(空值及非空值时不作处理) ${file:-my.file.txt}：假如 $file 没有设定或为空值，则使用 my.file.txt 作传回值。 (非空值时不作处理) ${file+my.file.txt}：假如 $file 设为空值或非空值，均使用 my.file.txt 作传回值。(没设定时不作处理) ${file:+my.file.txt}：若 $file 为非空值，则使用 my.file.txt 作传回值。 (没设定及空值时不作处理) ${file=my.file.txt}：若 $file 没设定，则使用 my.file.txt 作传回值，同时将 $file 赋值为 my.file.txt。 (空值及非空值时不作处理) ${file:=my.file.txt}：若 $file 没设定或为空值，则使用 my.file.txt 作传回值，同时将 $file 赋值为 my.file.txt 。 (非空值时不作处理) ${file?my.file.txt}：若 $file 没设定，则将 my.file.txt 输出至 STDERR。 (空值及非空值时不作处理) ${file:?my.file.txt}：若 $file 没设定或为空值，则将 my.file.txt 输出至 STDERR。 (非空值时不作处理) tips:以上的理解在于, 你一定要分清楚 unset 与 null 及 non-null 这三种赋值状态.一般而言, : 与 null 有关, 若不带 : 的话, null 不受影响, 若带 : 则连 null 也受影响. 参考资料： https://my.oschina.net/flylxl/blog/510960 http://www.chinaunix.net/forum/viewtopic.php?t=201843","categories":[{"name":"系统","slug":"系统","permalink":"https://github.com/zzycreate/categories/系统/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/zzycreate/tags/Linux/"},{"name":"shell","slug":"shell","permalink":"https://github.com/zzycreate/tags/shell/"},{"name":"bash","slug":"bash","permalink":"https://github.com/zzycreate/tags/bash/"}]},{"title":"linux防火墙设置","slug":"linux防火墙设置","date":"2017-04-03T22:40:07.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"2017/04/03/linux防火墙设置/","link":"","permalink":"https://github.com/zzycreate/2017/04/03/linux防火墙设置/","excerpt":"linux防火墙设置的记录","text":"linux防火墙设置的记录 查看防火墙状态：/etc/init.d/iptables status 暂时关闭防火墙：/etc/init.d/iptables stop 禁止防火墙在系统启动时启动/sbin/chkconfig --level 2345 iptables off 重启iptables:/etc/init.d/iptables restart 修改防火墙规则：vi /etc/sysconfig/iptables新增一条-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 39764 -j ACCEPT类似的记录就会开放指定的39764端口 重启后生效开启： chkconfig iptables on 关闭： chkconfig iptables off 或者 /sbin/chkconfig --level 2345 iptables off 即时生效，重启后失效service 方式开启： service iptables start 关闭： service iptables stopiptables方式查看防火墙状态：/etc/init.d/iptables status暂时关闭防火墙：/etc/init.d/iptables stop重启iptables:/etc/init.d/iptables restart","categories":[{"name":"系统","slug":"系统","permalink":"https://github.com/zzycreate/categories/系统/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/zzycreate/tags/Linux/"},{"name":"firewall","slug":"firewall","permalink":"https://github.com/zzycreate/tags/firewall/"}]},{"title":"CentOS安装JDK","slug":"CentOS安装JDK","date":"2017-04-02T21:48:23.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"2017/04/02/CentOS安装JDK/","link":"","permalink":"https://github.com/zzycreate/2017/04/02/CentOS安装JDK/","excerpt":"CentOS系统安装JDK的操作记录","text":"CentOS系统安装JDK的操作记录 JDK的安装进入java官网，选择linux的rpm安装程序，获得下载地址 在CentOS中使用wget 后面跟上上面得到的下载地址，可以直接将rpm格式的jdk下载到当前目录。 为了便于操作可以 mv jdkxxxx.rpm jdk.rpm，便于安装使用。 使用rpm命令进行安装 rpm -ivh jdk.rpm jdk 会默认安装在/usr/java目录下。 执行java -version可以查看java版本。 设置环境变量vi /etc/profile 在profile文件尾部添加 #set java environmentJAVA_HOME=/usr/java/defaultJRE_HOME=/usr/java/default/jrePATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/libexport JAVA_HOME JRE_HOME PATH CLASSPATH 然后执行 source /etc/profile 更新环境变量使之前的配置生效。","categories":[{"name":"系统","slug":"系统","permalink":"https://github.com/zzycreate/categories/系统/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/zzycreate/tags/Linux/"},{"name":"jdk","slug":"jdk","permalink":"https://github.com/zzycreate/tags/jdk/"},{"name":"CentOS","slug":"CentOS","permalink":"https://github.com/zzycreate/tags/CentOS/"}]},{"title":"JAVA中的引用","slug":"JAVA中的引用","date":"2017-03-13T09:50:53.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"2017/03/13/JAVA中的引用/","link":"","permalink":"https://github.com/zzycreate/2017/03/13/JAVA中的引用/","excerpt":"Java中没有指针，到处都是引用(除了基本类型)。Java中有个java.lang.ref包，这里面都是描述引用对象的，包括了Reference，SoftReference，WeakReference和PhantomReference。其中，Reference是基类其他三个类的基类。","text":"Java中没有指针，到处都是引用(除了基本类型)。Java中有个java.lang.ref包，这里面都是描述引用对象的，包括了Reference，SoftReference，WeakReference和PhantomReference。其中，Reference是基类其他三个类的基类。 强引用(Strong References)直接 new 一个对象，就是创建一个对象(对象在堆中)，并把一个强引用存到一个声明的引用上。强引用之所以”强”的地方在于其对垃圾回收器所产生的影响。如果一个对象可以经由一条强引用链可达(Strongly reachable)，那么这个类就不适合被垃圾回收器回收。 但是强引用会对我们的应用产生很强的影响，在应用运行过程中经常会有集合，不停地向集合中添加元素，会产生一大堆的强引用，而这些强引用并不会被垃圾回收机制所回收，终有一天应用会因为 Out Of Memory 而死掉。 弱引用(Weak References)弱引用就是用强制的方式要求对象存在于内存中的引用。可以通过垃圾回收机制判断某个对象的可达性，并帮助你回收弱引用所引用的对象。 StringBuffer sbuf = new StringBuffer(&quot;weak reference&quot;);WeakReference&lt;StringBuffer&gt; wref = new WeakReference&lt;StringBuffer&gt;(sbuf);sbuf = null; sbuf 最开始是一个强引用，使用 WeakReference 引用 sbuf 这个引用，而生成一个弱引用。由于弱引用也会被垃圾回收器所回收，所有不会因此产生内存溢出的问题。 引用队列(Reference Queue)当 WeakReference 开始返回 null 的时候，说明它所指向的对象已经变成了垃圾，同时这个弱引用也会变得没有用处，可以使用 ReferenceQueue 来处理。当检测到相应的可达性发生改变后，垃圾回收器就会将注册有此队列的引用对象添加到这个引用队列中。 软引用(Soft Reference)软引用和弱引用相似，但是软引用指向的对象会比弱引用的存活时间要长，直到内存空间不足的时候，才会被垃圾回收机制回收。一个 Weakly reachable 对象，是仅仅被 WeakReference 引用的，并且会被垃圾回收机制在下一个垃圾回收周期中丢弃；而 Softly Reference 对象则会活得时间长一些。 软引用可以带来很多的便利，尤其是缓存的实现。例如我们实现一个缓存池，在内存比较紧张的情况下，一旦达到内存溢出的时候，垃圾回收器就会将 Soft Reference 引用的对象释放掉，以避免 OutOfMemery 的发生。 虚引用(Phantom Reference)幻象引用，是不同于 Soft 和 Weak 的引用。幻象引用对指向对象的引用强度如此之脆弱，以至于调用方法 get() 时，总是返回 null。它的主要作用就是跟踪所指向的对象已经 dead 了，那么其跟 WeakReference 的区别是什么呢？ 它们的区别就在于：是在什么时候，这个引用对象被添加到引用队列中的。WeakReference 是在当其所引用的对象变成 Weakly Reachable 时被添加到引用队列中的，这发生在一个对象被 finalization 或被垃圾回收之前的。理论上讲，一个对象在被 finalize() 时，是可以被“复活”的，但此时 WeakReference 已经没活力了。对幻象引用来说，只有当其所引用的对象被彻底垃圾回收（从内存中消除）时，才会添加到引用队列中。而幻象引用的 get 方法总是返回 null，就是要避免我们来“复活”一个奄奄一息的对象。 虚引用可以用来监控一个对象什么时候被彻底销毁了。 虚引用其实仅用来处理资源的清理问题，比 Object 里面的 finalize 机制更灵活。get 方法返回的永远是 null，Java 虚拟机不负责清理虚引用，但是它会把虚引用放到引用队列里面。 因为理论上存在的，可以通过一个对象的 finalize() 方法“复活”一个对象，那么如果在一次垃圾回收处理时，调用了一个对象的 finalize()（这个方法在何时调用不确定），却让它复活了。要再苦苦等待 finalize() 的执行，还不知道要到猴年马月的（天下大赦可以有，但不是天天有。谁知道啥时候天朝更替，人主易位）。突然就出现了 OutOfMemory 错误了。而幻象引用绝对不会再让对象复活，只要被它逮着了，引用必然就会被回收。 按照一个对象的引用可达(Reachable)强度，由强到弱分为5类，如下:1. 强可达(Strong Reachable)在一个线程内，无需引用直接可达，新创建的对象是强可达的。 2. 软可达(Soft Reachable)不是强可达的，但是通过一个软引用(SoftReference)可达。3. 弱可达(Weakly Reachable)既不是强可达也不是软可达，但是通过一个弱引用(WeakReference)可达。4. 虚可达(Phantom Reachable)既不是强可达，不是软可达，也不是弱可达，但是通过一个虚引用(PhantomReference)可达。5. 不可达(Unreachable)没有任何引用指向对象。 比较好、容易理解的是Java垃圾回收器会优先清理可达强度低的对象。另外有两个重要的点: 强可达的一定不会被清理 JVM保证抛出out of memory之前，清理所有的软引用对象","categories":[{"name":"编码","slug":"编码","permalink":"https://github.com/zzycreate/categories/编码/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/zzycreate/tags/java/"}]},{"title":"vi的一些设置","slug":"vi的一些设置","date":"2017-03-02T21:43:27.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"2017/03/02/vi的一些设置/","link":"","permalink":"https://github.com/zzycreate/2017/03/02/vi的一些设置/","excerpt":"记录一些使用vi时的设置","text":"记录一些使用vi时的设置 安装增强版vi：sudo apt-get install vim 做一个软链接：sudo ln -sf /usr/bin/vim /usr/bin/vi 这一步可以省略，因为这只是个人习惯问题，但是，输入vi，怎么也比输入vim要来的快一点吧。 新建一个vi的配置文件：sudo vi /etc/vim/vimrc.local 在里面添加下面的内容，保存。 set nocompatible &quot;去掉讨厌的有关vim一致性模式,避免以前版本的一些bug和局限.set number &quot;显示行号.set ruler &quot;显示当前光标的行列信息syntax on &quot;语法高亮显示.(这个肯定是要的.)set background=dark &quot;背景颜色暗色.(我觉得不错,保护眼睛.)set history=50 &quot;设置命令历史记录为50条.set hls &quot;寻找匹配是高亮度显示的set lbr &quot;不在单词中间断行。set fo+=mB &quot;打开断行模块对亚洲语言支持set backspace=indent,eol,startset tabstop=4 &quot;设置tab键为4个空格.set shiftwidth=4 &quot;设置当行之间交错时使用4个空格set whichwrap=b,s,&lt;,&gt;,[,]filetype on &quot;检测文件的类型set autoindent &quot;使用自动对起，也就是把当前行的对起格式应用到下一行.set smartindent &quot;依据上面的对起格式，智能的选择对起方式，对于类似C语言编.set showmatch &quot;设置匹配模式，显示括号配对情况。set cin &quot; 打开 C/C++ 风格的自动缩进。set cino=:4g4t4(sus &quot;设定 C/C++ 风格自动缩进的选项set vb t_vb= &quot;当vim进行编辑时，如果命令错误，会发出一个响声，该设置去掉响set incsearch &quot;搜索时在未完全输入完毕要检索的文本时就开始检索。filetype plugin indent on &quot;开启了Vim的三种智能:自动识别文件类型、autocmd FileType text setlocal textwidth=78autocmd BufReadPost * \\if line(&quot;°\\&quot;&quot;)&gt;0&amp;&amp;line(&quot;°\\&quot;&quot;)&lt;=line(&quot;$&quot;)| \\ exe &quot;normal g`\\&quot;&quot;| \\endifhighlight Search term=reverse ctermbg=4 ctermfg=7highlight Normal ctermbg=black ctermfg=whitehighlight Comment ctermfg=Cyanset completeopt=longest,menuset tags=../tagsset tags=tags&quot; 用空格键来开关折叠set foldenableset foldmethod=manualnnoremap &lt;space&gt; @=((foldclosed(line(&apos;.&apos;)) &lt; 0) ? &apos;zc&apos; : &apos;zo&apos;)&lt;CR&gt;&quot;if has(“vms”)&quot;&quot; set nobackup&quot;else&quot;&quot; set backup 添加对中文的友好支持，要修改用户目录下的一个隐藏文件vi ~/.vimrc 添加下面的两行： let &amp;termencoding=&amp;encodingset fileencodings=utf-8,gbk,ucs-bom,cp936 参考地址：http://www.linuxidc.com/Linux/2014-02/96396.htm","categories":[{"name":"工具","slug":"工具","permalink":"https://github.com/zzycreate/categories/工具/"}],"tags":[{"name":"vi","slug":"vi","permalink":"https://github.com/zzycreate/tags/vi/"},{"name":"tools","slug":"tools","permalink":"https://github.com/zzycreate/tags/tools/"}]},{"title":"Linux的软件安装方式","slug":"Linux的软件安装方式","date":"2017-01-30T20:22:18.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"2017/01/30/Linux的软件安装方式/","link":"","permalink":"https://github.com/zzycreate/2017/01/30/Linux的软件安装方式/","excerpt":"Linux 作为开源的操作系统，有着众多的发行版，不同的发行版本安装 Linux 软件的方式可能有很大的差异。在互联网上搜索安装某个 Linux 软件，可能会有不同的安装方式。","text":"Linux 作为开源的操作系统，有着众多的发行版，不同的发行版本安装 Linux 软件的方式可能有很大的差异。在互联网上搜索安装某个 Linux 软件，可能会有不同的安装方式。 Linux 怎么安装应用软件？我的软件安装在什么地方？如何删除不要的应用软件？……下面，我们就一起来认识一下这些方面的问题。 Linux系统分类一般来说著名的 Linux 系统基本上分两大类： RedHat 系列：Redhat、Centos、Fedora 等 Debian 系列：Debian、Ubuntu 等 Dpkg (Debian系)：Ubuntu RPM (Red Hat系)：CentOS、Fedora RedHat 系列 常见的安装包格式 rpm 包，安装rpm包的命令是“rpm -参数” 包管理工具 yum 支持 tar 包 Debian 系列 常见的安装包格式 deb 包，安装 deb 包的命令是“dpkg -参数” 包管理工具 apt-get 支持 tar 包 tar 只是一种压缩文件格式，所以，它只是把文件压缩打包而已。 rpm 相当于windows中的安装文件，它会自动处理软件包之间的依赖关系。优缺点来说，rpm一般都是预先编译好的文件，它可能已经绑定到某种CPU或者发行版上面了。 Linux 软件安装包Linux 软件包的类型通常Linux应用软件的安装包有三种： tar包，如 software-1.2.3-1.tar.gz。它是使用UNIX系统的打包工具tar打包的。 rpm包，如 software-1.2.3-1.i386.rpm。它是 Redhat Linux 提供的一种包封装格式。 dpkg包，如 software-1.2.3-1.deb。它是 Debain Linux 提供的一种包封装格式。 Linux软件包的命名而且，大多数Linux应用软件包的命名也有一定的规律，它遵循：名称-版本-修正版-类型 例如： 1） software-1.2.3-1.tar.gz 的含义： 软件名称：software版本号：1.2.3修正版本：1类型：tar.gz，说明是一个tar包。 2） software-1.2.3-1.i386.rpm 的含义： 软件名称：software版本号：1.2.3修正版本：1可用平台：i386，适用于Intel 80x86平台。类型：rpm，说明是一个rpm包。 注意：由于rpm格式的通常是已编译的程序，所以需指明平台。在后面会详细说明。 而software-1.2.3-1.deb就不用再说了吧！大家自己练习一下。 Linux 软件包里的内容一个 Linux 应用程序的软件包中可以包含两种不同的内容： 一种就是可执行文件，也就是解开包后就可以直接运行的。在Windows中所 有的软件包都是这种类型。安装完这个程序后，你就可以使用，但你看不到源程序。而且下载时要注意这个软件是否是你所使用的平台，否则将无法正常安装。 另一种则是源程序，也就解开包后，你还需要使用编译器将其编译成为可执行文件。这在Windows系统中是几乎没有的，因为Windows的思想是不开放源程序的。 通常，用tar打包的，都是源程序；而用rpm、dpkg打包的则常是可执行程序。一般来说，自己动手编译源程序能够更具灵活性，但也容易遇到各种问题和困难。而相对来说，下载那些可执行程序包，反而是更容易完成软件的安装，当然那样灵活性就差多了。所以一般一个软件总会提供多种打包格式的安装程序的。你可以根据自己的情况来选择。 Linux 各种软件包的使用使用tar打包的应用软件tar包的安装整个安装过程可以分为以下几步： 取得应用软件：通过下载、购买光盘的方法获得； 解压缩文件：一般tar包，都会再做一次压缩，如gzip、bz2等，所以你需要先解压。如果是最常见的gz格式，则可以执行 tar –xvzf 软件包名，就可以一步完成解压与解包工作。如果不是，则先用解压软件，再执行 tar –xvf 解压后的tar包 进行解包； 阅读附带的INSTALL文件、README文件； 执行 ./configur” 命令为编译做好准备； 执行 make 命令进行软件编译； 执行 make install 完成安装； 执行 make clean 删除安装时产生的临时文件。 好了，到此大功告成。我们就可以运行应用程序了。但这时，有的读者就会问，我怎么执行呢？这也是一个Linux特色的问题。其实，一般来说， Linux的应用软件的可执行文件会存放在/usr/local/bin目录下！不过这并不是“放四海皆准”的真理，最可靠的还是看这个软件的 INSTALL和README文件，一般都会有说明。 ===安装目录：注意make install命令过程中的安装目录，或者阅读安装目录里面的readme文件，当然最好的办法是在安装的过程中指定安装目录，即在./configure命令后面加参数–prefix=/**， 如：./configure --prefix=/usr/local/aaaa，即把软件装在/usr/local/路径的aaaa这个目录里。一般的软件的默认安装目录在/usr/local或者/opt里，可以到那里去找找 tar包的卸载通常软件的开发者很少考虑到如何卸载自己的软件，而tar又仅是完成打包的工作，所以并没有提供良好的卸载方法。那么是不是说就不能够卸载呢！其实也不是，有两个软件能够解决这个问题，那就是 Kinstall 和 Kife ，它们是tar包安装、卸载的黄金搭档。有兴趣可以研究下。 不需要安装的软件有一些tar包其实算是不需要安装的软件，类似于 windows 下的绿色软件有了些软件，比如 lumaqq 是不需要安装的，自带jre解压缩后可直接运行。假设下载的是 lumaqq.tar.gz ，使用方法如下： 打开一个终端，su -成root用户； tar -xzvf lumaqq.tar.gz //这一步会生成一个叫LumaQQ的目录 cd LumaQQ chmod +x lumaqq //设置lumaqq这个程序文件为可运行 此时就可以运行lumaqq了，用命令./lumaqq即可，但每次运行要输入全路径或切换到刚才生成的LumaQQ目录里 为了保证不设置路径就可以用，你可以在/bin目录下建立一个lumaqq的链接，用命令ln -s lumaqq /bin/ 即可，以后任何时候打开一个终端输入lumaqq就可以启动QQ聊天软件了 如果你要想lumaqq有个菜单项，使用菜单编辑工具，比如Alacarte MenuEditor，找到上面生成的LumaQQ目录里的lumaqq设置一个菜单项就可以了，当然你也可以直接到 /usr/share/applications目录，按照里面其它*.desktop文件的格式生成一个自己的desktop文件即可。 使用rpm打包的应用软件RPM 打包方式是 Redhat 公司的一大贡献，它使 Linux 的软件安装工作变得更加简单容易。 rpm包的安装：只需简单的一句话，就可以说完。执行： rpm –ivh rpm软件包名查找安装目录，执行命令查找： rpm -ql firefox-1.0.1-1.3.2 rpm 更高级的用法，如下： rpm 部分参数及参数说明： -i 安装软件 -t 测试安装，不是真的安装 -p 显示安装进度 -f 忽略任何错误 -U 升级安装 -v 检测套件是否正确安装 这些参数可以同时采用。更多的内容可以参考RPM的命令帮助。 rpm包的卸载：同样只需简单的一句话，就可以完成。执行： rpm –e 软件名不过要注意的是，后面使用的是软件名，而不是软件包名。例如，要安装software-1.2.3-1.i386.rpm这个包时，应执行： rpm –ivh software-1.2.3-1.i386.rpm而当卸载时，则应执行： rpm –e software 另外，在 Linux 中还提供了象 GnoRPM 、kpackage 等图形化的RPM工具，使得整个过程会更加简单。 使用yum命令安装rpm包应用程序yum 全称为 Yellow dog Updater, Modified 是一个在 Fedora 和 RedHat 以及 SUSE 等 Linux 发行版中的 Shell 前端软件包管理器。基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。yum 提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。 yum install 全部安装yum install package1 安装指定的安装包package1yum update 全部更新yum update package1 更新指定程序包package1yum list 显示所有已经安装和可以安装的程序包yum list package1 显示指定程序包安装情况package1yum remove package1 删除程序包package1yum search keyword 查找软件包 使用deb打包的应用程序​deb 格式包是 Debian Linux 提供的一个包管理器，它与 RPM 十分类似。但由于 RPM 出现得更早，所以在各种版本的 Linux 都常见到。而 debian 的包管理器 dpkg 则只出现在 Debina Linux 中，其它 Linux 版本一般都没有。我们在此就简单地说明一下： deb包的安装执行 dpkg –i deb软件包名如：dpkg –i software-1.2.3-1.deb deb包的卸载执行 dpkg –e 软件名如：dpkg –e software 使用apt命令安装deb包应用程序apt 的全称是 Advanced Packaging Tool 是Linux系统下的一款安装包管理工具。最初需要在 Linux 系统中安装软件，需要自行编译各类软件，缺乏一个统一管理软件包的工具。此后当 Debian 系统出现后，dpkg 管理工具也就被设计出来了，此后为了更加快捷、方便的安装各类软件，dpkg的前端工具 APT 也出现了。在 Ubuntu16.04 系统下 apt 命令功能又得到了强化，使其更加方便快捷和受欢迎了。 打开一个终端，su -成root用户； apt-cache search soft 注：soft是你要找的软件的名称或相关信息 如果2中找到了软件soft.version，则用 apt-get install soft.version 命令安装软件。（注：只要你可以上网，只需要用 apt-cache search 查找软件，用 apt-get install 安装软件。 卸载：apt-get uninstall 软件 使用bin源码进行应用程序安装如果你下载到的软件名是soft.bin，一般情况下是个可执行文件，安装方法如下： 打开一个终端，su - 成root用户； chmod +x soft.bin 添加可执行属性 ./soft.bin 运行这个命令就可以安装软件了 卸载：删除安装该软件的安装包即可以 安装完软件后如何执行。 安装完软件后可以有好多种方法执行软件: 有些软件安装后会自动在应用程序列表里加上快捷键，和windows一样，到那里找就行了。 如果在应用程序列表里找不到的话，可以直接在/开始/运行命令里输入命令：启动命令一般就是软件名，如firefox，realplay，xmms等 也可以打开一个shell终端，输入软件名，和在“运行命令”里一样。如果不知道命令全程的话，可以输入开头的字母，然后按tab键查找，系统会自动显示以输入字母开头的所有命令/ 你也可以直接到安装目录下运行启动文件，Linux下的可执行图标和shell终端图标很像 到 /usr/bin 目录里找安装的软件启动文件执行命令。Linux 系统把所有可执行的文件命令在/usr/bin目录里都作了启动连接，你可以去那个目录寻找你安装的文件的启动命令，双击启动。 参考文章： http://blog.csdn.net/shun01/article/details/22041339 http://www.cnblogs.com/zhangfeionline/p/5893748.html","categories":[{"name":"系统","slug":"系统","permalink":"https://github.com/zzycreate/categories/系统/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/zzycreate/tags/Linux/"},{"name":"rpm","slug":"rpm","permalink":"https://github.com/zzycreate/tags/rpm/"},{"name":"deb","slug":"deb","permalink":"https://github.com/zzycreate/tags/deb/"}]},{"title":"普通用户sudo权限问题","slug":"普通用户sudo权限问题","date":"2017-01-25T21:32:56.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"2017/01/25/普通用户sudo权限问题/","link":"","permalink":"https://github.com/zzycreate/2017/01/25/普通用户sudo权限问题/","excerpt":"","text":"在虚拟机中安装一个ubuntu系统，执行一些sudo命令时出现 xxx is not in the sudoers file.This incident will be reported. 的提示. 切换到root用户下su - 切换root用户 添加sudo文件的写权限chmod u+w /etc/sudoers 编辑sudoers文件vi /etc/sudoers 找到这行 root ALL=(ALL) ALL,在他下面添加xxx ALL=(ALL) ALL (这里的xxx是你的用户名) ps:这里说下你可以sudoers添加下面四行中任意一条 youuser ALL=(ALL) ALL%youuser ALL=(ALL) ALLyouuser ALL=(ALL) NOPASSWD: ALL%youuser ALL=(ALL) NOPASSWD: ALL 第一行:允许用户youuser执行sudo命令(需要输入密码).第二行:允许用户组youuser里面的用户执行sudo命令(需要输入密码).第三行:允许用户youuser执行sudo命令,并且在执行的时候不输入密码.第四行:允许用户组youuser里面的用户执行sudo命令,并且在执行的时候不输入密码. 撤销sudoers文件写权限chmod u-w /etc/sudoers 这样普通用户就可以使用sudo了. 参考文章：http://blog.csdn.net/u010622887/article/details/46911469","categories":[{"name":"系统","slug":"系统","permalink":"https://github.com/zzycreate/categories/系统/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/zzycreate/tags/Linux/"},{"name":"sudo","slug":"sudo","permalink":"https://github.com/zzycreate/tags/sudo/"}]},{"title":"npm下载慢的解决方法","slug":"npm下载慢的解决方法","date":"2017-01-19T02:00:23.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"2017/01/19/npm下载慢的解决方法/","link":"","permalink":"https://github.com/zzycreate/2017/01/19/npm下载慢的解决方法/","excerpt":"国内访问外网都很慢，甚至不能访问！大家都懂，都很无奈！安装 Node 时自带的 npm 地址默认是：http://registry.npmjs.org ，访问很慢！ 没事，咱们换成国内的！怎么换？","text":"国内访问外网都很慢，甚至不能访问！大家都懂，都很无奈！安装 Node 时自带的 npm 地址默认是：http://registry.npmjs.org ，访问很慢！ 没事，咱们换成国内的！怎么换？ 设置第三方的npm源通过config命令npm config set registry http://registry.cnpmjs.org # 随便检查一个npm库的信息npm info underscore （如果上面配置正确这个命令会有字符串response） 命令行指定npm --registry http://registry.cnpmjs.org 编辑 node_modules\\npm.npmrc 加入下面内容registry = http://registry.cnpmjs.org 如果上面的 npm 地址不行的话，大家可以试试淘宝的 npm，也非常稳定: 地址：https://registry.npm.taobao.org 使用 nrm 管理 npm 源nrm 是一个开源的 npm 注册源管理程序，可以使用 nrm 进行查看及快速的换源操作。 安装nrm$ npm install -g nrm 查看可以选择的源$ nrm ls* npm ---- https://registry.npmjs.org/ cnpm --- http://r.cnpmjs.org/ eu ----- http://registry.npmjs.eu/ au ----- http://registry.npmjs.org.au/ sl ----- http://npm.strongloop.com/ nj ----- https://registry.nodejitsu.com/ 快速切换npm注册源$ nrm use cnpm //switch registry to cnpm Registry has been set to: http://r.cnpmjs.org/ 新增和删除私有源nrm add &lt;registry&gt; &lt;url&gt; [home]nrm del &lt;registry&gt; 注册源速度测试nrm test npm ---- 891ms cnpm --- 1213ms* taobao - 460ms eu ----- 3859ms au ----- 1073ms sl ----- 4150ms nj ----- 8008ms","categories":[{"name":"编码","slug":"编码","permalink":"https://github.com/zzycreate/categories/编码/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/zzycreate/tags/javascript/"},{"name":"node","slug":"node","permalink":"https://github.com/zzycreate/tags/node/"},{"name":"npm","slug":"npm","permalink":"https://github.com/zzycreate/tags/npm/"}]},{"title":"npm全局安装与本地安装","slug":"npm全局安装与本地安装","date":"2017-01-03T02:15:56.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"2017/01/03/npm全局安装与本地安装/","link":"","permalink":"https://github.com/zzycreate/2017/01/03/npm全局安装与本地安装/","excerpt":"","text":"在使用node进行javascript开发的时候，必然会用到npm；npm的设计导致的问题有其历史原因，官方提供的全局安装和本地安装两种方式，在使用的时候根据需要进行全局安装或者本地安装。 什么是全局安装以gulp为例，全局安装方式是键入命令：npm install gulp -g 或 npm install gulp --global，其中参数-g的含义是代表安装到全局环境里面，包安装在Node安装目录下的node_modules文件夹中，windows一般在 \\Users\\用户名\\AppData\\Roaming\\目录下，可以使用npm root -g查看全局安装目录。 $ npm root -gC:\\Users\\用户名\\AppData\\Roaming\\npm\\node_modules 全局安装的调用方式全局安装后可以供命令行(command line)使用，用户可以在命令行中直接运行该组件包支持的命令。 什么是本地安装以gulp为例，本地安装方式是键入命令：npm install gulp或 npm install gulp --save-dev等，其中参数--save-dev的含义是代表把你的安装包信息写入package.json文件的devDependencies字段中，包安装在指定项目的node_modules文件夹下。 本地安装的调用方式本地安装后可以直接通过require()的方式引入项目中node_modules目录下的模块。 为什么全局安装后还要本地安装 在js实例代码中，默认下node.js会在NODE_PATH和目前js所在项目下的node_modules文件夹下去寻找模块，因此，如果只是全局安装，不能直接通过require()的方式去引用模块，需要手动解决包路径的配置问题，当然你也可以复制全局安装的node_modules文件夹到项目下，还有办法可以选择将环境变量的NODE_PATH设置为C:\\Program Files\\nodejs。 对于包的更新不好管理，可能你需要为每个包重新命名，如gulp@3.8.1、gulp@3.9.1…，为了区别不同项目使用指定的包，保证模块之间的相互依赖（这块下面会介绍），区别每个项目正常运行。 因此，不推荐只全局安装。 最早的node.js/npm实际上是全局的，包括现在还兼容NODE_PATH，但是不能支持全局多版本，于是nodejs团队改成本地安装的方法可能就是为了保证不同版本包之间的相互依赖。依赖包的版本号，有时候是不可轻易去修改，因为不同版本包对应依赖包的版本的功能有所差别，如果修改指定的版本来运行，就可能会编译出错等bug。 每一次的更新可能带来不一样的功能，在多人合作、发布模块到npmjs社区、上传到github给其他人使用时，保留模块的版本信息可用于下载指定的版本号显得特别重要。 本地安装可以让每个项目拥有独立的包，不受全局包的影响，方便项目的移动、复制、打包等，保证不同版本包之间的相互依赖，这些优点是全局安装难以做到的。","categories":[{"name":"编码","slug":"编码","permalink":"https://github.com/zzycreate/categories/编码/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/zzycreate/tags/javascript/"},{"name":"node","slug":"node","permalink":"https://github.com/zzycreate/tags/node/"},{"name":"npm","slug":"npm","permalink":"https://github.com/zzycreate/tags/npm/"}]},{"title":"js生成二维码以及点击下载二维码","slug":"js生成二维码以及点击下载二维码","date":"2016-12-30T02:27:37.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"2016/12/30/js生成二维码以及点击下载二维码/","link":"","permalink":"https://github.com/zzycreate/2016/12/30/js生成二维码以及点击下载二维码/","excerpt":"在完成一个页面生成并下载二维码的工作任务时，碰到了一些问题，记录于此。","text":"在完成一个页面生成并下载二维码的工作任务时，碰到了一些问题，记录于此。 js生成二维码jquery.qrcode.js可以快速使用页面生成二维码。但改项目有两个小问题：1.不支持中文；2.不支持二维码中间生成图片。 支持中文的jquery-qrcodejquery.qrcode.js默认不支持中文。这跟js的机制有关系，jquery-qrcode这个库是采用 charCodeAt()这个方式进行编码转换的， 而这个方法默认会获取它的 Unicode 编码，一般的解码器都是采用UTF-8, ISO-8859-1等方式，英文是没有问题，如果是中文，一般情况下Unicode是UTF-16实现，长度2位，而UTF-8编码是3位，这样二维码的编解码就不匹配了。 jquery-qrcode GitHub源码地址 : https://github.com/jeromeetienne/jquery-qrcode 解决方式当然是，在二维码编码前把字符串转换成UTF-8，具体代码如下： function qrcodeToUtf8(str) &#123; var out, i, len, c; out = \"\"; len = str.length; for (i = 0; i &lt; len; i++) &#123; c = str.charCodeAt(i); if ((c &gt;= 0x0001) &amp;&amp; (c &lt;= 0x007F)) &#123; out += str.charAt(i); &#125; else if (c &gt; 0x07FF) &#123; out += String.fromCharCode(0xE0 | ((c &gt;&gt; 12) &amp; 0x0F)); out += String.fromCharCode(0x80 | ((c &gt;&gt; 6) &amp; 0x3F)); out += String.fromCharCode(0x80 | ((c &gt;&gt; 0) &amp; 0x3F)); &#125; else &#123; out += String.fromCharCode(0xC0 | ((c &gt;&gt; 6) &amp; 0x1F)); out += String.fromCharCode(0x80 | ((c &gt;&gt; 0) &amp; 0x3F)); &#125; &#125; return out;&#125; 支持带logo的二维码生成增加qrcode的设置属性： &#123; width : \"220\", //二维码的宽度 height : \"220\", //二维码的高度 imgWidth : 220/4, //图片宽 imgHeight : 220/4, //图片高 src: 'logo.png' //图片中央的二维码&#125; 生成二维码的时候会将src地址中的图片放进标签中，覆盖到生成二位码的canvas中。 将中文转义和logo添加功能整合进jquery.qrcode.js后代码如下（压缩版） : function qrcodeToUtf8(str)&#123;var out,i,len,c;out=\"\";len=str.length;for(i=0;i&lt;len;i++)&#123;c=str.charCodeAt(i);if((c&gt;=0x0001)&amp;&amp;(c&lt;=0x007F))&#123;out+=str.charAt(i);&#125;else if(c&gt;0x07FF)&#123;out+=String.fromCharCode(0xE0|((c&gt;&gt;12)&amp;0x0F));out+=String.fromCharCode(0x80|((c&gt;&gt;6)&amp;0x3F));out+=String.fromCharCode(0x80|((c&gt;&gt;0)&amp;0x3F));&#125;else&#123;out+=String.fromCharCode(0xC0|((c&gt;&gt;6)&amp;0x1F));out+=String.fromCharCode(0x80|((c&gt;&gt;0)&amp;0x3F));&#125;&#125;return out;&#125;function QR8bitByte(a)&#123;this.mode=QRMode.MODE_8BIT_BYTE,this.data=a&#125;function QRCode(a,b)&#123;this.typeNumber=a,this.errorCorrectLevel=b,this.modules=null,this.moduleCount=0,this.dataCache=null,this.dataList=new Array()&#125;function QRPolynomial(a,b)&#123;var c,d;if(void 0==a.length)&#123;throw new Error(a.length+\"/\"+b)&#125;for(c=0;c&lt;a.length&amp;&amp;0==a[c];)&#123;c++&#125;for(this.num=new Array(a.length-c+b),d=0;d&lt;a.length-c;d++)&#123;this.num[d]=a[d+c]&#125;&#125;function QRRSBlock(a,b)&#123;this.totalCount=a,this.dataCount=b&#125;function QRBitBuffer()&#123;this.buffer=new Array(),this.length=0&#125;var QRMode,QRErrorCorrectLevel,QRMaskPattern,QRUtil,QRMath,i;for(function(a)&#123;a.fn.qrcode=function(b)&#123;var c,d;return\"string\"==typeof b&amp;&amp;(b=&#123;text:b&#125;),b=a.extend(&#123;&#125;,&#123;render:\"canvas\",width:256,height:256,imgWidth:b.width/4.7,imgHeight:b.height/4,typeNumber:-1,correctLevel:QRErrorCorrectLevel.H,background:\"#ffffff\",foreground:\"#000000\"&#125;,b),c=function()&#123;var c,d,e,f,g,h,i,j,k,a=new QRCode(b.typeNumber,b.correctLevel);for(a.addData(qrcodeToUtf8(b.text)),a.make(),c=document.createElement(\"canvas\"),c.width=b.width,c.height=b.height,d=c.getContext(\"2d\"),b.src&amp;&amp;(e=new Image(),e.src=b.src,e.onload=function()&#123;d.drawImage(e,(b.width-b.imgWidth)/2,(b.height-b.imgHeight)/2,b.imgWidth,b.imgHeight)&#125;),f=b.width/a.getModuleCount(),g=b.height/a.getModuleCount(),h=0;h&lt;a.getModuleCount();h++)&#123;for(i=0;i&lt;a.getModuleCount();i++)&#123;d.fillStyle=a.isDark(h,i)?b.foreground:b.background,j=Math.ceil((i+1)*f)-Math.floor(i*f),k=Math.ceil((h+1)*f)-Math.floor(h*f),d.fillRect(Math.round(i*f),Math.round(h*g),j,k)&#125;&#125;return c&#125;,d=function()&#123;var d,e,f,g,h,i,c=new QRCode(b.typeNumber,b.correctLevel);for(c.addData(qrcodeToUtf8(b.text)),c.make(),d=a(\"&lt;table&gt;&lt;/table&gt;\").css(\"width\",b.width+\"px\").css(\"height\",b.height+\"px\").css(\"border\",\"0px\").css(\"border-collapse\",\"collapse\").css(\"background-color\",b.background),e=b.width/c.getModuleCount(),f=b.height/c.getModuleCount(),g=0;g&lt;c.getModuleCount();g++)&#123;for(h=a(\"&lt;tr&gt;&lt;/tr&gt;\").css(\"height\",f+\"px\").appendTo(d),i=0;i&lt;c.getModuleCount();i++)&#123;a(\"&lt;td&gt;&lt;/td&gt;\").css(\"width\",e+\"px\").css(\"background-color\",c.isDark(g,i)?b.foreground:b.background).appendTo(h)&#125;&#125;return d&#125;,this.each(function()&#123;var e=\"canvas\"==b.render?c():d();a(e).appendTo(this)&#125;)&#125;&#125;(jQuery),QR8bitByte.prototype=&#123;getLength:function()&#123;return this.data.length&#125;,write:function(a)&#123;for(var b=0;b&lt;this.data.length;b++)&#123;a.put(this.data.charCodeAt(b),8)&#125;&#125;&#125;,QRCode.prototype=&#123;addData:function(a)&#123;var b=new QR8bitByte(a);this.dataList.push(b),this.dataCache=null&#125;,isDark:function(a,b)&#123;if(0&gt;a||this.moduleCount&lt;=a||0&gt;b||this.moduleCount&lt;=b)&#123;throw new Error(a+\",\"+b)&#125;return this.modules[a][b]&#125;,getModuleCount:function()&#123;return this.moduleCount&#125;,make:function()&#123;var a,b,c,d,e,f;if(this.typeNumber&lt;1)&#123;for(a=1,a=1;40&gt;a;a++)&#123;for(b=QRRSBlock.getRSBlocks(a,this.errorCorrectLevel),c=new QRBitBuffer(),d=0,e=0;e&lt;b.length;e++)&#123;d+=b[e].dataCount&#125;for(e=0;e&lt;this.dataList.length;e++)&#123;f=this.dataList[e],c.put(f.mode,4),c.put(f.getLength(),QRUtil.getLengthInBits(f.mode,a)),f.write(c)&#125;if(c.getLengthInBits()&lt;=8*d)&#123;break&#125;&#125;this.typeNumber=a&#125;this.makeImpl(!1,this.getBestMaskPattern())&#125;,makeImpl:function(a,b)&#123;var c,d;for(this.moduleCount=4*this.typeNumber+17,this.modules=new Array(this.moduleCount),c=0;c&lt;this.moduleCount;c++)&#123;for(this.modules[c]=new Array(this.moduleCount),d=0;d&lt;this.moduleCount;d++)&#123;this.modules[c][d]=null&#125;&#125;this.setupPositionProbePattern(0,0),this.setupPositionProbePattern(this.moduleCount-7,0),this.setupPositionProbePattern(0,this.moduleCount-7),this.setupPositionAdjustPattern(),this.setupTimingPattern(),this.setupTypeInfo(a,b),this.typeNumber&gt;=7&amp;&amp;this.setupTypeNumber(a),null==this.dataCache&amp;&amp;(this.dataCache=QRCode.createData(this.typeNumber,this.errorCorrectLevel,this.dataList)),this.mapData(this.dataCache,b)&#125;,setupPositionProbePattern:function(a,b)&#123;var c,d;for(c=-1;7&gt;=c;c++)&#123;if(!(-1&gt;=a+c||this.moduleCount&lt;=a+c))&#123;for(d=-1;7&gt;=d;d++)&#123;-1&gt;=b+d||this.moduleCount&lt;=b+d||(this.modules[a+c][b+d]=c&gt;=0&amp;&amp;6&gt;=c&amp;&amp;(0==d||6==d)||d&gt;=0&amp;&amp;6&gt;=d&amp;&amp;(0==c||6==c)||c&gt;=2&amp;&amp;4&gt;=c&amp;&amp;d&gt;=2&amp;&amp;4&gt;=d?!0:!1)&#125;&#125;&#125;&#125;,getBestMaskPattern:function()&#123;var c,d,a=0,b=0;for(c=0;8&gt;c;c++)&#123;this.makeImpl(!0,c),d=QRUtil.getLostPoint(this),(0==c||a&gt;d)&amp;&amp;(a=d,b=c)&#125;return b&#125;,createMovieClip:function(a,b,c)&#123;var f,g,h,i,j,d=a.createEmptyMovieClip(b,c),e=1;for(this.make(),f=0;f&lt;this.modules.length;f++)&#123;for(g=f*e,h=0;h&lt;this.modules[f].length;h++)&#123;i=h*e,j=this.modules[f][h],j&amp;&amp;(d.beginFill(0,100),d.moveTo(i,g),d.lineTo(i+e,g),d.lineTo(i+e,g+e),d.lineTo(i,g+e),d.endFill())&#125;&#125;return d&#125;,setupTimingPattern:function()&#123;var a,b;for(a=8;a&lt;this.moduleCount-8;a++)&#123;null==this.modules[a][6]&amp;&amp;(this.modules[a][6]=0==a%2)&#125;for(b=8;b&lt;this.moduleCount-8;b++)&#123;null==this.modules[6][b]&amp;&amp;(this.modules[6][b]=0==b%2)&#125;&#125;,setupPositionAdjustPattern:function()&#123;var b,c,d,e,f,g,a=QRUtil.getPatternPosition(this.typeNumber);for(b=0;b&lt;a.length;b++)&#123;for(c=0;c&lt;a.length;c++)&#123;if(d=a[b],e=a[c],null==this.modules[d][e])&#123;for(f=-2;2&gt;=f;f++)&#123;for(g=-2;2&gt;=g;g++)&#123;this.modules[d+f][e+g]=-2==f||2==f||-2==g||2==g||0==f&amp;&amp;0==g?!0:!1&#125;&#125;&#125;&#125;&#125;&#125;,setupTypeNumber:function(a)&#123;var c,d,b=QRUtil.getBCHTypeNumber(this.typeNumber);for(c=0;18&gt;c;c++)&#123;d=!a&amp;&amp;1==(1&amp;b&gt;&gt;c),this.modules[Math.floor(c/3)][c%3+this.moduleCount-8-3]=d&#125;for(c=0;18&gt;c;c++)&#123;d=!a&amp;&amp;1==(1&amp;b&gt;&gt;c),this.modules[c%3+this.moduleCount-8-3][Math.floor(c/3)]=d&#125;&#125;,setupTypeInfo:function(a,b)&#123;var e,f,c=this.errorCorrectLevel&lt;&lt;3|b,d=QRUtil.getBCHTypeInfo(c);for(e=0;15&gt;e;e++)&#123;f=!a&amp;&amp;1==(1&amp;d&gt;&gt;e),6&gt;e?this.modules[e][8]=f:8&gt;e?this.modules[e+1][8]=f:this.modules[this.moduleCount-15+e][8]=f&#125;for(e=0;15&gt;e;e++)&#123;f=!a&amp;&amp;1==(1&amp;d&gt;&gt;e),8&gt;e?this.modules[8][this.moduleCount-e-1]=f:9&gt;e?this.modules[8][15-e-1+1]=f:this.modules[8][15-e-1]=f&#125;this.modules[this.moduleCount-8][8]=!a&#125;,mapData:function(a,b)&#123;var g,h,i,j,c=-1,d=this.moduleCount-1,e=7,f=0;for(g=this.moduleCount-1;g&gt;0;g-=2)&#123;for(6==g&amp;&amp;g--;;)&#123;for(h=0;2&gt;h;h++)&#123;null==this.modules[d][g-h]&amp;&amp;(i=!1,f&lt;a.length&amp;&amp;(i=1==(1&amp;a[f]&gt;&gt;&gt;e)),j=QRUtil.getMask(b,d,g-h),j&amp;&amp;(i=!i),this.modules[d][g-h]=i,e--,-1==e&amp;&amp;(f++,e=7))&#125;if(d+=c,0&gt;d||this.moduleCount&lt;=d)&#123;d-=c,c=-c;break&#125;&#125;&#125;&#125;&#125;,QRCode.PAD0=236,QRCode.PAD1=17,QRCode.createData=function(a,b,c)&#123;var f,g,h,d=QRRSBlock.getRSBlocks(a,b),e=new QRBitBuffer();for(f=0;f&lt;c.length;f++)&#123;g=c[f],e.put(g.mode,4),e.put(g.getLength(),QRUtil.getLengthInBits(g.mode,a)),g.write(e)&#125;for(h=0,f=0;f&lt;d.length;f++)&#123;h+=d[f].dataCount&#125;if(e.getLengthInBits()&gt;8*h)&#123;throw new Error(\"code length overflow. (\"+e.getLengthInBits()+\"&gt;\"+8*h+\")\")&#125;for(e.getLengthInBits()+4&lt;=8*h&amp;&amp;e.put(0,4);0!=e.getLengthInBits()%8;)&#123;e.putBit(!1)&#125;for(;;)&#123;if(e.getLengthInBits()&gt;=8*h)&#123;break&#125;if(e.put(QRCode.PAD0,8),e.getLengthInBits()&gt;=8*h)&#123;break&#125;e.put(QRCode.PAD1,8)&#125;return QRCode.createBytes(e,d)&#125;,QRCode.createBytes=function(a,b)&#123;var h,i,j,k,l,m,n,o,p,q,r,c=0,d=0,e=0,f=new Array(b.length),g=new Array(b.length);for(h=0;h&lt;b.length;h++)&#123;for(i=b[h].dataCount,j=b[h].totalCount-i,d=Math.max(d,i),e=Math.max(e,j),f[h]=new Array(i),k=0;k&lt;f[h].length;k++)&#123;f[h][k]=255&amp;a.buffer[k+c]&#125;for(c+=i,l=QRUtil.getErrorCorrectPolynomial(j),m=new QRPolynomial(f[h],l.getLength()-1),n=m.mod(l),g[h]=new Array(l.getLength()-1),k=0;k&lt;g[h].length;k++)&#123;o=k+n.getLength()-g[h].length,g[h][k]=o&gt;=0?n.get(o):0&#125;&#125;for(p=0,k=0;k&lt;b.length;k++)&#123;p+=b[k].totalCount&#125;for(q=new Array(p),r=0,k=0;d&gt;k;k++)&#123;for(h=0;h&lt;b.length;h++)&#123;k&lt;f[h].length&amp;&amp;(q[r++]=f[h][k])&#125;&#125;for(k=0;e&gt;k;k++)&#123;for(h=0;h&lt;b.length;h++)&#123;k&lt;g[h].length&amp;&amp;(q[r++]=g[h][k])&#125;&#125;return q&#125;,QRMode=&#123;MODE_NUMBER:1,MODE_ALPHA_NUM:2,MODE_8BIT_BYTE:4,MODE_KANJI:8&#125;,QRErrorCorrectLevel=&#123;L:1,M:0,Q:3,H:2&#125;,QRMaskPattern=&#123;PATTERN000:0,PATTERN001:1,PATTERN010:2,PATTERN011:3,PATTERN100:4,PATTERN101:5,PATTERN110:6,PATTERN111:7&#125;,QRUtil=&#123;PATTERN_POSITION_TABLE:[[],[6,18],[6,22],[6,26],[6,30],[6,34],[6,22,38],[6,24,42],[6,26,46],[6,28,50],[6,30,54],[6,32,58],[6,34,62],[6,26,46,66],[6,26,48,70],[6,26,50,74],[6,30,54,78],[6,30,56,82],[6,30,58,86],[6,34,62,90],[6,28,50,72,94],[6,26,50,74,98],[6,30,54,78,102],[6,28,54,80,106],[6,32,58,84,110],[6,30,58,86,114],[6,34,62,90,118],[6,26,50,74,98,122],[6,30,54,78,102,126],[6,26,52,78,104,130],[6,30,56,82,108,134],[6,34,60,86,112,138],[6,30,58,86,114,142],[6,34,62,90,118,146],[6,30,54,78,102,126,150],[6,24,50,76,102,128,154],[6,28,54,80,106,132,158],[6,32,58,84,110,136,162],[6,26,54,82,110,138,166],[6,30,58,86,114,142,170]],G15:1335,G18:7973,G15_MASK:21522,getBCHTypeInfo:function(a)&#123;for(var b=a&lt;&lt;10;QRUtil.getBCHDigit(b)-QRUtil.getBCHDigit(QRUtil.G15)&gt;=0;)&#123;b^=QRUtil.G15&lt;&lt;QRUtil.getBCHDigit(b)-QRUtil.getBCHDigit(QRUtil.G15)&#125;return(a&lt;&lt;10|b)^QRUtil.G15_MASK&#125;,getBCHTypeNumber:function(a)&#123;for(var b=a&lt;&lt;12;QRUtil.getBCHDigit(b)-QRUtil.getBCHDigit(QRUtil.G18)&gt;=0;)&#123;b^=QRUtil.G18&lt;&lt;QRUtil.getBCHDigit(b)-QRUtil.getBCHDigit(QRUtil.G18)&#125;return a&lt;&lt;12|b&#125;,getBCHDigit:function(a)&#123;for(var b=0;0!=a;)&#123;b++,a&gt;&gt;&gt;=1&#125;return b&#125;,getPatternPosition:function(a)&#123;return QRUtil.PATTERN_POSITION_TABLE[a-1]&#125;,getMask:function(a,b,c)&#123;switch(a)&#123;case QRMaskPattern.PATTERN000:return 0==(b+c)%2;case QRMaskPattern.PATTERN001:return 0==b%2;case QRMaskPattern.PATTERN010:return 0==c%3;case QRMaskPattern.PATTERN011:return 0==(b+c)%3;case QRMaskPattern.PATTERN100:return 0==(Math.floor(b/2)+Math.floor(c/3))%2;case QRMaskPattern.PATTERN101:return 0==b*c%2+b*c%3;case QRMaskPattern.PATTERN110:return 0==(b*c%2+b*c%3)%2;case QRMaskPattern.PATTERN111:return 0==(b*c%3+(b+c)%2)%2;default:throw new Error(\"bad maskPattern:\"+a)&#125;&#125;,getErrorCorrectPolynomial:function(a)&#123;var c,b=new QRPolynomial([1],0);for(c=0;a&gt;c;c++)&#123;b=b.multiply(new QRPolynomial([1,QRMath.gexp(c)],0))&#125;return b&#125;,getLengthInBits:function(a,b)&#123;if(b&gt;=1&amp;&amp;10&gt;b)&#123;switch(a)&#123;case QRMode.MODE_NUMBER:return 10;case QRMode.MODE_ALPHA_NUM:return 9;case QRMode.MODE_8BIT_BYTE:return 8;case QRMode.MODE_KANJI:return 8;default:throw new Error(\"mode:\"+a)&#125;&#125;else&#123;if(27&gt;b)&#123;switch(a)&#123;case QRMode.MODE_NUMBER:return 12;case QRMode.MODE_ALPHA_NUM:return 11;case QRMode.MODE_8BIT_BYTE:return 16;case QRMode.MODE_KANJI:return 10;default:throw new Error(\"mode:\"+a)&#125;&#125;else&#123;if(!(41&gt;b))&#123;throw new Error(\"type:\"+b)&#125;switch(a)&#123;case QRMode.MODE_NUMBER:return 14;case QRMode.MODE_ALPHA_NUM:return 13;case QRMode.MODE_8BIT_BYTE:return 16;case QRMode.MODE_KANJI:return 12;default:throw new Error(\"mode:\"+a)&#125;&#125;&#125;&#125;,getLostPoint:function(a)&#123;var d,e,f,g,h,i,j,k,l,b=a.getModuleCount(),c=0;for(d=0;b&gt;d;d++)&#123;for(e=0;b&gt;e;e++)&#123;for(f=0,g=a.isDark(d,e),h=-1;1&gt;=h;h++)&#123;if(!(0&gt;d+h||d+h&gt;=b))&#123;for(i=-1;1&gt;=i;i++)&#123;0&gt;e+i||e+i&gt;=b||(0!=h||0!=i)&amp;&amp;g==a.isDark(d+h,e+i)&amp;&amp;f++&#125;&#125;&#125;f&gt;5&amp;&amp;(c+=3+f-5)&#125;&#125;for(d=0;b-1&gt;d;d++)&#123;for(e=0;b-1&gt;e;e++)&#123;j=0,a.isDark(d,e)&amp;&amp;j++,a.isDark(d+1,e)&amp;&amp;j++,a.isDark(d,e+1)&amp;&amp;j++,a.isDark(d+1,e+1)&amp;&amp;j++,(0==j||4==j)&amp;&amp;(c+=3)&#125;&#125;for(d=0;b&gt;d;d++)&#123;for(e=0;b-6&gt;e;e++)&#123;a.isDark(d,e)&amp;&amp;!a.isDark(d,e+1)&amp;&amp;a.isDark(d,e+2)&amp;&amp;a.isDark(d,e+3)&amp;&amp;a.isDark(d,e+4)&amp;&amp;!a.isDark(d,e+5)&amp;&amp;a.isDark(d,e+6)&amp;&amp;(c+=40)&#125;&#125;for(e=0;b&gt;e;e++)&#123;for(d=0;b-6&gt;d;d++)&#123;a.isDark(d,e)&amp;&amp;!a.isDark(d+1,e)&amp;&amp;a.isDark(d+2,e)&amp;&amp;a.isDark(d+3,e)&amp;&amp;a.isDark(d+4,e)&amp;&amp;!a.isDark(d+5,e)&amp;&amp;a.isDark(d+6,e)&amp;&amp;(c+=40)&#125;&#125;for(k=0,e=0;b&gt;e;e++)&#123;for(d=0;b&gt;d;d++)&#123;a.isDark(d,e)&amp;&amp;k++&#125;&#125;return l=Math.abs(100*k/b/b-50)/5,c+=10*l&#125;&#125;,QRMath=&#123;glog:function(a)&#123;if(1&gt;a)&#123;throw new Error(\"glog(\"+a+\")\")&#125;return QRMath.LOG_TABLE[a]&#125;,gexp:function(a)&#123;for(;0&gt;a;)&#123;a+=255&#125;for(;a&gt;=256;)&#123;a-=255&#125;return QRMath.EXP_TABLE[a]&#125;,EXP_TABLE:new Array(256),LOG_TABLE:new Array(256)&#125;,i=0;8&gt;i;i++)&#123;QRMath.EXP_TABLE[i]=1&lt;&lt;i&#125;for(i=8;256&gt;i;i++)&#123;QRMath.EXP_TABLE[i]=QRMath.EXP_TABLE[i-4]^QRMath.EXP_TABLE[i-5]^QRMath.EXP_TABLE[i-6]^QRMath.EXP_TABLE[i-8]&#125;for(i=0;255&gt;i;i++)&#123;QRMath.LOG_TABLE[QRMath.EXP_TABLE[i]]=i&#125;QRPolynomial.prototype=&#123;get:function(a)&#123;return this.num[a]&#125;,getLength:function()&#123;return this.num.length&#125;,multiply:function(a)&#123;var c,d,b=new Array(this.getLength()+a.getLength()-1);for(c=0;c&lt;this.getLength();c++)&#123;for(d=0;d&lt;a.getLength();d++)&#123;b[c+d]^=QRMath.gexp(QRMath.glog(this.get(c))+QRMath.glog(a.get(d)))&#125;&#125;return new QRPolynomial(b,0)&#125;,mod:function(a)&#123;var b,c,d;if(this.getLength()-a.getLength()&lt;0)&#123;return this&#125;for(b=QRMath.glog(this.get(0))-QRMath.glog(a.get(0)),c=new Array(this.getLength()),d=0;d&lt;this.getLength();d++)&#123;c[d]=this.get(d)&#125;for(d=0;d&lt;a.getLength();d++)&#123;c[d]^=QRMath.gexp(QRMath.glog(a.get(d))+b)&#125;return new QRPolynomial(c,0).mod(a)&#125;&#125;,QRRSBlock.RS_BLOCK_TABLE=[[1,26,19],[1,26,16],[1,26,13],[1,26,9],[1,44,34],[1,44,28],[1,44,22],[1,44,16],[1,70,55],[1,70,44],[2,35,17],[2,35,13],[1,100,80],[2,50,32],[2,50,24],[4,25,9],[1,134,108],[2,67,43],[2,33,15,2,34,16],[2,33,11,2,34,12],[2,86,68],[4,43,27],[4,43,19],[4,43,15],[2,98,78],[4,49,31],[2,32,14,4,33,15],[4,39,13,1,40,14],[2,121,97],[2,60,38,2,61,39],[4,40,18,2,41,19],[4,40,14,2,41,15],[2,146,116],[3,58,36,2,59,37],[4,36,16,4,37,17],[4,36,12,4,37,13],[2,86,68,2,87,69],[4,69,43,1,70,44],[6,43,19,2,44,20],[6,43,15,2,44,16],[4,101,81],[1,80,50,4,81,51],[4,50,22,4,51,23],[3,36,12,8,37,13],[2,116,92,2,117,93],[6,58,36,2,59,37],[4,46,20,6,47,21],[7,42,14,4,43,15],[4,133,107],[8,59,37,1,60,38],[8,44,20,4,45,21],[12,33,11,4,34,12],[3,145,115,1,146,116],[4,64,40,5,65,41],[11,36,16,5,37,17],[11,36,12,5,37,13],[5,109,87,1,110,88],[5,65,41,5,66,42],[5,54,24,7,55,25],[11,36,12],[5,122,98,1,123,99],[7,73,45,3,74,46],[15,43,19,2,44,20],[3,45,15,13,46,16],[1,135,107,5,136,108],[10,74,46,1,75,47],[1,50,22,15,51,23],[2,42,14,17,43,15],[5,150,120,1,151,121],[9,69,43,4,70,44],[17,50,22,1,51,23],[2,42,14,19,43,15],[3,141,113,4,142,114],[3,70,44,11,71,45],[17,47,21,4,48,22],[9,39,13,16,40,14],[3,135,107,5,136,108],[3,67,41,13,68,42],[15,54,24,5,55,25],[15,43,15,10,44,16],[4,144,116,4,145,117],[17,68,42],[17,50,22,6,51,23],[19,46,16,6,47,17],[2,139,111,7,140,112],[17,74,46],[7,54,24,16,55,25],[34,37,13],[4,151,121,5,152,122],[4,75,47,14,76,48],[11,54,24,14,55,25],[16,45,15,14,46,16],[6,147,117,4,148,118],[6,73,45,14,74,46],[11,54,24,16,55,25],[30,46,16,2,47,17],[8,132,106,4,133,107],[8,75,47,13,76,48],[7,54,24,22,55,25],[22,45,15,13,46,16],[10,142,114,2,143,115],[19,74,46,4,75,47],[28,50,22,6,51,23],[33,46,16,4,47,17],[8,152,122,4,153,123],[22,73,45,3,74,46],[8,53,23,26,54,24],[12,45,15,28,46,16],[3,147,117,10,148,118],[3,73,45,23,74,46],[4,54,24,31,55,25],[11,45,15,31,46,16],[7,146,116,7,147,117],[21,73,45,7,74,46],[1,53,23,37,54,24],[19,45,15,26,46,16],[5,145,115,10,146,116],[19,75,47,10,76,48],[15,54,24,25,55,25],[23,45,15,25,46,16],[13,145,115,3,146,116],[2,74,46,29,75,47],[42,54,24,1,55,25],[23,45,15,28,46,16],[17,145,115],[10,74,46,23,75,47],[10,54,24,35,55,25],[19,45,15,35,46,16],[17,145,115,1,146,116],[14,74,46,21,75,47],[29,54,24,19,55,25],[11,45,15,46,46,16],[13,145,115,6,146,116],[14,74,46,23,75,47],[44,54,24,7,55,25],[59,46,16,1,47,17],[12,151,121,7,152,122],[12,75,47,26,76,48],[39,54,24,14,55,25],[22,45,15,41,46,16],[6,151,121,14,152,122],[6,75,47,34,76,48],[46,54,24,10,55,25],[2,45,15,64,46,16],[17,152,122,4,153,123],[29,74,46,14,75,47],[49,54,24,10,55,25],[24,45,15,46,46,16],[4,152,122,18,153,123],[13,74,46,32,75,47],[48,54,24,14,55,25],[42,45,15,32,46,16],[20,147,117,4,148,118],[40,75,47,7,76,48],[43,54,24,22,55,25],[10,45,15,67,46,16],[19,148,118,6,149,119],[18,75,47,31,76,48],[34,54,24,34,55,25],[20,45,15,61,46,16]],QRRSBlock.getRSBlocks=function(a,b)&#123;var d,e,f,g,h,i,j,c=QRRSBlock.getRsBlockTable(a,b);if(void 0==c)&#123;throw new Error(\"bad rs block @ typeNumber:\"+a+\"/errorCorrectLevel:\"+b)&#125;for(d=c.length/3,e=new Array(),f=0;d&gt;f;f++)&#123;for(g=c[3*f+0],h=c[3*f+1],i=c[3*f+2],j=0;g&gt;j;j++)&#123;e.push(new QRRSBlock(h,i))&#125;&#125;return e&#125;,QRRSBlock.getRsBlockTable=function(a,b)&#123;switch(b)&#123;case QRErrorCorrectLevel.L:return QRRSBlock.RS_BLOCK_TABLE[4*(a-1)+0];case QRErrorCorrectLevel.M:return QRRSBlock.RS_BLOCK_TABLE[4*(a-1)+1];case QRErrorCorrectLevel.Q:return QRRSBlock.RS_BLOCK_TABLE[4*(a-1)+2];case QRErrorCorrectLevel.H:return QRRSBlock.RS_BLOCK_TABLE[4*(a-1)+3];default:return void 0&#125;&#125;,QRBitBuffer.prototype=&#123;get:function(a)&#123;var b=Math.floor(a/8);return 1==(1&amp;this.buffer[b]&gt;&gt;&gt;7-a%8)&#125;,put:function(a,b)&#123;for(var c=0;b&gt;c;c++)&#123;this.putBit(1==(1&amp;a&gt;&gt;&gt;b-c-1))&#125;&#125;,getLengthInBits:function()&#123;return this.length&#125;,putBit:function(a)&#123;var b=Math.floor(this.length/8);this.buffer.length&lt;=b&amp;&amp;this.buffer.push(0),a&amp;&amp;(this.buffer[b]|=128&gt;&gt;&gt;this.length%8),this.length++&#125;&#125;; 若要使用可以将以上代码复制到jquery.qrcode.logo.min.js，再在html代码中导入该文件，使用jquery.qrcode.logo.min.js之前务必要导入jquery的源文件。 HTML: &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Qrcode Test&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-1.12.0.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/jquery.qrcode.logo.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; //创建二维码 function createQRCode(id, url, width, height, src)&#123; $('#'+id).empty(); jQuery('#'+id).qrcode(&#123; render: 'canvas', text: url, width : width, //二维码的宽度 height : height, //二维码的高度 imgWidth : width/4, //图片宽 imgHeight : height/4, //图片高 src: src //图片中央的二维码 &#125;); &#125; function init() &#123; createQRCode(\"qrcode\", \"测试\", 220, 220, \"img/logo.png\"); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body onLoad=\"init()\"&gt; &lt;h1&gt;Qrcode&lt;/h1&gt; &lt;div id=\"qrcode\"&gt;&lt;/div&gt; &lt;p class=\"col-lg-6 col-md-6\" style=\"text-align: left;\" &gt; &lt;a id=\"download\" download=\"qrcode.jpg\"&gt;&lt;/a&gt; &lt;a id=\"saveQrCode\" style=\"cursor: pointer;\"&gt;下载二维码&lt;/a&gt; &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 点击下载二位码我想做得项目需求要求页面点击直接调用浏览器的下载工具，下载二维码图片。 由于要调用浏览器下载，要将上文中qrcode生成的canvas生成下载用的jpg图片，找了很多方法发现很难实现一个方法兼容所有，于是整合了两种方式下载， 方法1：使用html5的画布canvas转换为base64编码流输出，到一个a标签的href中，点击触发download属性下载（该方法无法在IE上使用，由于ie的href支持的字符数较短，好像只有两百多个字符，难以支持一个jpg文件的base64编码结果）； 方法2：正对ie使用blob对象转换canvas对象，然后调用浏览器navigator对象的方法进行下载（该方法在非IE浏览器上无法使用，由于没有msToBlod是IE自创的方法，所有其他浏览器使用会报错，使用try catch进行处理整合两种方法）。 以上方法仅测试Chrome，FIreFox，IE10，如有其他问题可以有针对性的进行处理。 $('#saveQrCode').click(function()&#123; var canvas = $('#qrcode').find(\"canvas\").get(0); try &#123;//解决IE转base64时缓存不足，canvas转blob下载 var blob = canvas.msToBlob(); navigator.msSaveBlob(blob, 'qrcode.jpg'); &#125; catch (e) &#123;//如果为其他浏览器，使用base64转码下载 var url = canvas.toDataURL('image/jpeg'); $(\"#download\").attr('href', url).get(0).click(); &#125; return false;&#125;); 参考： https://my.oschina.net/xuwang1993/blog/647291 http://blog.csdn.net/gao36951/article/details/48975353","categories":[{"name":"编码","slug":"编码","permalink":"https://github.com/zzycreate/categories/编码/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/zzycreate/tags/javascript/"},{"name":"ie","slug":"ie","permalink":"https://github.com/zzycreate/tags/ie/"},{"name":"chrome","slug":"chrome","permalink":"https://github.com/zzycreate/tags/chrome/"}]},{"title":"Ubuntu安装sshd","slug":"Ubuntu安装sshd","date":"2016-12-28T23:49:39.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"2016/12/28/Ubuntu安装sshd/","link":"","permalink":"https://github.com/zzycreate/2016/12/28/Ubuntu安装sshd/","excerpt":"","text":"ubuntu系统安装sshd的步骤记录 安装ssh1.安装ssh-server sudo apt-get install openssh-server 2.安装ssh-client sudo apt-get install openssh-client 确认sshserver是否安装好ps -e | grep sshd 结果为 450 ? 00:00:00 sshd 如果看到sshd，则说明ssh-server已启动。如果只有ssh-agent，说明ssh-server还没有启动，需要执行命令启动ssh服务： /etc/init.d/ssh start; 启动 ssh 服务# 重启SSH服务：sudo /etc/init.d/ssh restart# 重新启动下ssh服务service sshd restart ubuntu16.04 开机启动# 检查ssh服务是否为开机启动chkconfig --list sshd# 设置开机启动ssh服务chkconfig --level 2345 sshd on ubuntu18.10 开机启动# 开机自动启动ssh命令sudo systemctl enable ssh# 关闭ssh开机自动启动命令sudo systemctl disable ssh# 单次开启sshsudo systemctl start ssh# 单次关闭sshsudo systemctl stop ssh# 设置好后重启系统reboot# 查看ssh是否启动，看到Active: active (running)即表示成功sudo systemctl status ssh 验证是否启动了22端口netstat -antp |grep sshd 22端口为ssh默认端口，确认ssh服务开启状态 允许 root 远程登录sudo vi /etc/ssh/sshd_config 修改参数 PermitRootLogin yes, 默认为 # PermitRootLogin prohibit-password 不过，强烈建议不要开启 root 远程登录，使用普通用户和 sudo 即可","categories":[{"name":"系统","slug":"系统","permalink":"https://github.com/zzycreate/categories/系统/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://github.com/zzycreate/tags/Ubuntu/"},{"name":"ssh","slug":"ssh","permalink":"https://github.com/zzycreate/tags/ssh/"}]},{"title":"Ubuntu安装JDK","slug":"Ubuntu安装JDK","date":"2016-12-28T23:42:40.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"2016/12/28/Ubuntu安装JDK/","link":"","permalink":"https://github.com/zzycreate/2016/12/28/Ubuntu安装JDK/","excerpt":"Ubuntu上安装JDK1.7，操作记录。","text":"Ubuntu上安装JDK1.7，操作记录。 1.去官网下载linux版的JDK使用VMware Tools将jdk-7u79-linux-x64 .tar.gz包复制到/home/用户名/java路径中 2.创建jdk安装目录以便存放下载解压的包 sudo mkdir /usr/lib/jdk 3.解压jdk压缩包到指定位置，先进入压缩包目录 cd /home/用户名/java，在进行解压操作 sudo tar -zxvf jdk-7u79-linux-x64 .tar.gz -C /usr/lib/jdk 4.进入/usr/lib/jdk cd /usr/lib/jdk 5.解压后的目录名重命名一遍后续使用 sudo mv jdk-7u79-linux-x64 jdk1.7 6.备份.bashrc文件 sudo cp ~/.bashrc ~/.bashrc.bak 使用vi编辑器修改环境配置 vi ~/.bashrc 在文件最后添加内容 export JAVA_HOME=/usr/lib/jdk/jdk1.7export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 7.应用配置文件 source ~/.bashrc 8.测试java安装结果 java -version","categories":[{"name":"系统","slug":"系统","permalink":"https://github.com/zzycreate/categories/系统/"}],"tags":[{"name":"jdk","slug":"jdk","permalink":"https://github.com/zzycreate/tags/jdk/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://github.com/zzycreate/tags/Ubuntu/"}]},{"title":"Ubuntu系统在VMware中显示过小","slug":"Ubuntu系统在VMware中显示过小","date":"2016-12-28T02:38:59.000Z","updated":"2020-05-12T01:17:23.859Z","comments":true,"path":"2016/12/28/Ubuntu系统在VMware中显示过小/","link":"","permalink":"https://github.com/zzycreate/2016/12/28/Ubuntu系统在VMware中显示过小/","excerpt":"安装Ubuntu之后，显示画面非常小，System Settings中设置分辨率则提示Unknown Display。无法通过设置调节屏幕分辨率。","text":"安装Ubuntu之后，显示画面非常小，System Settings中设置分辨率则提示Unknown Display。无法通过设置调节屏幕分辨率。 解决办法：可以使用xrandr命令调节分辨率。其中 * 表示当前分辨率。使用命令 xrandr -s 1440x900_59.89，即可设置分辨率为 1440x900上面这个命令是临时设置分辨率，如果需要永久设置需要 xrandr --output Virtual1 --mode 1440x900其中的Virtual1就是xrandr命令后的开头部分，后面的1440x900就是分辨率名称 其他自定义分辨率设置如果需要其他自定义分辨率设置这里需要用到两个工具： xrandr 和 cvt 用cvt增加一个新的分辨率，下面是创建一个1280x1024，刷新频率为60hz的分辨率xxx@xxx:~$ cvt 1280 1024 60&lt;br&gt;&lt;a&gt;# 1280x1024 59.89 Hz (CVT 1.31M4) hsync: 63.67 kHz; pclk: 109.00 MHz&lt;a&gt;&lt;br&gt;Modeline &quot;1280x1024_60.00&quot; 109.00 1280 1368 1496 1712 1024 1027 1034 1063 -hsync +vsync 将上面的 Modeline 用 xrandr 增加到显示器的分辨率列表中xxx@xxx:~$ xrandr --newmode &quot;1280x1024_60.00&quot; 109.00 1280 1368 1496 1712 1024 1027 1034 1063 -hsync +vsync 用 xrandr 可以看到刚才新添加的模式xxx@xxx:~$ xrandr&lt;br&gt;Screen 0: minimum 64 x 64, current 1280 x 960, maximum 16384 x 16384&lt;br&gt;VBOX0 connected 1280x960+0+0 0mm x 0mm 1024x768 60.0 + 60.0 1600x1200 60.0 1440x1050 60.0 1280x960 60.0* 800x600 60.0 640x480 60.0 1280x1024_60.00 (0x14d) 109.0MHz&lt;br&gt; h: width 1280 start 1368 end 1496 total 1712 skew 0 clock 63.7KHz&lt;br&gt; v: height 1024 start 1027 end 1034 total 1063 clock 59.9Hz 用 xrandr 的 –add-mode 命令添加模式：xxx@xxx:~$ xrandr --addmode VBOX0 &quot;1280x1024_60.00&quot;&lt;br&gt;xxx@xxx:~$ xrandr&lt;br&gt;Screen 0: minimum 64 x 64, current 1280 x 960, maximum 16384 x 16384&lt;br&gt;VBOX0 connected 1280x960+0+0 0mm x 0mm&lt;br&gt; 1024x768 60.0 + 60.0 1600x1200 60.0 1440x1050 60.0 1280x960 60.0* 800x600 60.0 640x480 60.0 1280x1024_60.00 59.9 可以看到，1280x1024 的分辨率已经添加到显示器的分辨率列表中了。 设置分辨率：xxx@xxx:~$ xrandr -s 1280x1024_60.00 持久地记忆这个新添加的分辨率 在~/.xprofile中加入下面语句xrandr --output VBOX0 --mode 1280x1024_60.00 参考原文： http://www.cnblogs.com/cobbliu/p/3818064.html http://www.myexception.cn/other/1933714.html","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/zzycreate/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://github.com/zzycreate/tags/Ubuntu/"},{"name":"VMWare","slug":"VMWare","permalink":"https://github.com/zzycreate/tags/VMWare/"}]}]}